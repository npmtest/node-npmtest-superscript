{"/home/travis/build/npmtest/node-npmtest-superscript/test.js":"/* istanbul instrument in package npmtest_superscript */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-superscript/lib.npmtest_superscript.js":"/* istanbul instrument in package npmtest_superscript */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_superscript = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_superscript = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-superscript/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-superscript && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_superscript */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_superscript\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_superscript.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_superscript.rollup.js'] =\n            local.assetsDict['/assets.npmtest_superscript.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_superscript.__dirname + '/lib.npmtest_superscript.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _requireDir = require('require-dir');\n\nvar _requireDir2 = _interopRequireDefault(_requireDir);\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nvar _ssMessage = require('ss-message');\n\nvar _ssMessage2 = _interopRequireDefault(_ssMessage);\n\nvar _common = require('./reply/common');\n\nvar _common2 = _interopRequireDefault(_common);\n\nvar _connect = require('./db/connect');\n\nvar _connect2 = _interopRequireDefault(_connect);\n\nvar _factSystem = require('./factSystem');\n\nvar _factSystem2 = _interopRequireDefault(_factSystem);\n\nvar _chatSystem = require('./chatSystem');\n\nvar _chatSystem2 = _interopRequireDefault(_chatSystem);\n\nvar _getReply = require('./getReply');\n\nvar _getReply2 = _interopRequireDefault(_getReply);\n\nvar _import = require('./db/import');\n\nvar _import2 = _interopRequireDefault(_import);\n\nvar _logger = require('./logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _debugLevels2.default)('SS:SuperScript');\n\nclass SuperScript {\n  constructor(coreChatSystem, coreFactSystem, plugins, scope, editMode, conversationTimeout, historyCheckpoints, tenantId = 'master') {\n    this.chatSystem = coreChatSystem.getChatSystem(tenantId);\n    this.factSystem = coreFactSystem.getFactSystem(tenantId);\n\n    // We want a place to store bot related data\n    this.memory = this.factSystem.createUserDB('botfacts');\n\n    this.scope = scope;\n    this.scope.bot = this;\n    this.scope.facts = this.factSystem;\n    this.scope.chatSystem = this.chatSystem;\n    this.scope.botfacts = this.memory;\n\n    this.plugins = plugins;\n    this.editMode = editMode;\n    this.conversationTimeout = conversationTimeout;\n    this.historyCheckpoints = historyCheckpoints;\n  }\n\n  importFile(filePath, callback) {\n    _import2.default.importFile(this.chatSystem, filePath, err => {\n      console.log('Bot is ready for input!');\n      debug.verbose('System loaded, waiting for replies');\n      callback(err);\n    });\n  }\n\n  getUsers(callback) {\n    this.chatSystem.User.find({}, 'id', callback);\n  }\n\n  getUser(userId, callback) {\n    this.chatSystem.User.findOne({ id: userId }).slice('history', this.historyCheckpoints).exec(callback);\n  }\n\n  findOrCreateUser(userId, callback) {\n    this.chatSystem.User.findOneAndUpdate({ id: userId }, {}, {\n      upsert: true,\n      setDefaultsOnInsert: true,\n      new: true\n    }).slice('history', this.historyCheckpoints).exec(callback);\n  }\n\n  // Converts msg into a message object, then checks for a match\n  reply(userId, messageString, callback, extraScope) {\n    // TODO: Check if random assignment of existing user ID causes problems\n    if (arguments.length === 2 && typeof messageString === 'function') {\n      callback = messageString;\n      messageString = userId;\n      userId = Math.random().toString(36).substr(2, 5);\n      extraScope = {};\n    }\n\n    debug.log(\"[ New Message - '%s']- %s\", userId, messageString);\n    const options = {\n      userId,\n      extraScope\n    };\n\n    this._reply(messageString, options, callback);\n  }\n\n  // This is like doing a topicRedirect\n  directReply(userId, topicName, messageString, callback) {\n    debug.log(\"[ New DirectReply - '%s']- %s\", userId, messageString);\n    const options = {\n      userId,\n      topicName,\n      extraScope: {}\n    };\n\n    this._reply(messageString, options, callback);\n  }\n\n  message(messageString, callback) {\n    const options = {\n      factSystem: this.factSystem\n    };\n\n    _ssMessage2.default.createMessage(messageString, options, (err, msgObj) => {\n      callback(null, msgObj);\n    });\n  }\n\n  _reply(messageString, options, callback) {\n    const system = {\n      // Pass in the topic if it has been set\n      topicName: options.topicName || null,\n      plugins: this.plugins,\n      scope: this.scope,\n      extraScope: options.extraScope,\n      chatSystem: this.chatSystem,\n      factSystem: this.factSystem,\n      editMode: this.editMode,\n      conversationTimeout: this.conversationTimeout,\n      defaultKeepScheme: 'exhaust',\n      defaultOrderScheme: 'random'\n    };\n\n    this.findOrCreateUser(options.userId, (err, user) => {\n      if (err) {\n        debug.error(err);\n      }\n\n      const messageOptions = {\n        factSystem: this.factSystem\n      };\n\n      _ssMessage2.default.createMessage(messageString, messageOptions, (err, messageObject) => {\n        _common2.default.getTopic(system.chatSystem, system.topicName).then(topicData => {\n          const options = {\n            user,\n            system,\n            depth: 0\n          };\n\n          if (topicData) {\n            options.pendingTopics = [topicData];\n          }\n\n          (0, _getReply2.default)(messageObject, options, (err, replyObj) => {\n            if (!replyObj) {\n              replyObj = {};\n              console.log('There was no response matched.');\n            }\n\n            user.updateHistory(messageObject, replyObj, (err, log) => {\n              // We send back a smaller message object to the clients.\n              const clientObject = {\n                replyId: replyObj.replyId,\n                createdAt: Date.now(),\n                string: replyObj.string || '',\n                topicName: replyObj.topicName,\n                subReplies: replyObj.subReplies,\n                debug: log\n              };\n\n              const newClientObject = _lodash2.default.merge(clientObject, replyObj.props || {});\n\n              debug.verbose(\"Update and Reply to user '%s'\", user.id, replyObj.string);\n              debug.info(\"[ Final Reply - '%s']- '%s'\", user.id, replyObj.string);\n\n              return callback(err, newClientObject);\n            });\n          });\n        });\n      });\n    });\n  }\n}\n\n/**\n *  This a class which has global settings for all bots on a certain database server,\n *  so we can reuse parts of the chat and fact systems and share plugins, whilst still\n *  being able to have multiple bots on different databases per server.\n */\nclass SuperScriptInstance {\n  constructor(coreChatSystem, coreFactSystem, options) {\n    this.coreChatSystem = coreChatSystem;\n    this.coreFactSystem = coreFactSystem;\n    this.plugins = [];\n\n    // This is a kill switch for filterBySeen which is useless in the editor.\n    this.editMode = options.editMode || false;\n    this.conversationTimeout = options.conversationTimeout;\n    this.historyCheckpoints = options.historyCheckpoints;\n    this.scope = options.scope || {};\n\n    // Built-in plugins\n    this.loadPlugins(`${__dirname}/../plugins`);\n\n    // For user plugins\n    if (options.pluginsPath) {\n      this.loadPlugins(options.pluginsPath);\n    }\n\n    if (options.messagePluginsPath) {\n      _ssMessage2.default.loadPlugins(options.messagePluginsPath);\n    }\n  }\n\n  loadPlugins(path) {\n    try {\n      const pluginFiles = (0, _requireDir2.default)(path);\n\n      Object.keys(pluginFiles).forEach(file => {\n        // For transpiled ES6 plugins with default export\n        if (pluginFiles[file].default) {\n          pluginFiles[file] = pluginFiles[file].default;\n        }\n\n        Object.keys(pluginFiles[file]).forEach(func => {\n          debug.verbose('Loading plugin: ', path, func);\n          this.plugins[func] = pluginFiles[file][func];\n        });\n      });\n    } catch (e) {\n      console.error(`Could not load plugins from ${path}: ${e}`);\n    }\n  }\n\n  getBot(tenantId) {\n    return new SuperScript(this.coreChatSystem, this.coreFactSystem, this.plugins, this.scope, this.editMode, this.conversationTimeout, this.historyCheckpoints, tenantId);\n  }\n}\n\nconst defaultOptions = {\n  mongoURI: 'mongodb://localhost/superscriptDB',\n  importFile: null,\n  factSystem: {\n    clean: false,\n    importFiles: null\n  },\n  scope: {},\n  editMode: false,\n  pluginsPath: `${process.cwd()}/plugins`,\n  messagePluginsPath: null,\n  logPath: `${process.cwd()}/logs`,\n  useMultitenancy: false,\n  conversationTimeout: 1000 * 300,\n  historyCheckpoints: 10\n};\n\n/**\n * Setup SuperScript. You may only run this a single time since it writes to global state.\n * @param {Object} options - Any configuration settings you want to use.\n * @param {String} options.mongoURI - The database URL you want to connect to.\n *                 This will be used for both the chat and fact system.\n * @param {String} options.importFile - Use this if you want to re-import your parsed\n *                 '*.json' file. Otherwise SuperScript will use whatever it currently\n *                 finds in the database.\n * @param {Object} options.factSystem - Settings to use for the fact system.\n * @param {Boolean} options.factSystem.clean - If you want to remove everything in the\n *                  fact system upon launch. Otherwise SuperScript will keep facts from\n *                  the last time it was run.\n * @param {Array} options.factSystem.importFiles - Any additional data you want to\n *                import into the fact system.\n * @param {Object} options.scope - Any extra scope you want to pass into your plugins.\n * @param {Boolean} options.editMode - Used in the editor.\n * @param {String} options.pluginsPath - A path to the plugins written by you. This loads\n *                 the entire directory recursively.\n * @param {String} options.logPath - If null, logging will be off. Otherwise writes\n *                 conversation transcripts to the path.\n * @param {Boolean} options.useMultitenancy - If true, will return a bot instance instead\n *                  of a bot, so you can get different tenancies of a single server. Otherwise,\n *                  returns a default bot in the 'master' tenancy.\n * @param {Number} options.conversationTimeout - The time to wait before a conversation expires,\n *                 so you start matching from the top-level triggers.\n */\nconst setup = function setup(options = {}, callback) {\n  options = _lodash2.default.merge(defaultOptions, options);\n\n  // Uses schemas to create models for the db connection to use\n  _factSystem2.default.setupFactSystem(options.mongoURI, options.factSystem, (err, coreFactSystem) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const db = (0, _connect2.default)(options.mongoURI);\n    const logger = new _logger2.default(options.logPath);\n    const coreChatSystem = _chatSystem2.default.setupChatSystem(db, coreFactSystem, logger);\n\n    const instance = new SuperScriptInstance(coreChatSystem, coreFactSystem, options);\n\n    /**\n     *  When you want to use multitenancy, don't return a bot, but instead an instance that can\n     *  get bots in different tenancies. Then you can just do:\n     *\n     *  instance.getBot('myBot');\n     */\n    if (options.useMultitenancy) {\n      return callback(null, instance);\n    }\n\n    const bot = instance.getBot('master');\n    if (options.importFile) {\n      return bot.importFile(options.importFile, err => callback(err, bot));\n    }\n    return callback(null, bot);\n  });\n};\n\nexports.default = {\n  setup\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/reply/common.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst debug = (0, _debugLevels2.default)('SS:ProcessHelpers');\n\nconst getTopic = (() => {\n  var _ref = _asyncToGenerator(function* (chatSystem, name) {\n    if (!name) {\n      // TODO: This should probably throw, not return null\n      return null;\n    }\n\n    debug.verbose('Getting topic data for', name);\n    const topicData = yield chatSystem.Topic.findOne({ name }).lean().exec();\n\n    if (!topicData) {\n      throw new Error(`No topic found for the topic name \"${name}\"`);\n    } else {\n      return { id: topicData._id, name, type: 'TOPIC' };\n    }\n  });\n\n  function getTopic(_x, _x2) {\n    return _ref.apply(this, arguments);\n  }\n\n  return getTopic;\n})();\n\nexports.default = {\n  getTopic\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/db/connect.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _mongoose = require('mongoose');\n\nvar _mongoose2 = _interopRequireDefault(_mongoose);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_mongoose2.default.Promise = global.Promise;\n\nexports.default = mongoURI => {\n  const db = _mongoose2.default.createConnection(`${mongoURI}`);\n\n  db.on('error', console.error);\n\n  // If you want to debug mongoose\n  // mongoose.set('debug', true);\n\n  return db;\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/factSystem.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _sfacts = require('sfacts');\n\nvar _sfacts2 = _interopRequireDefault(_sfacts);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst decorateFactSystem = function decorateFactSystem(factSystem) {\n  const getFactSystem = function getFactSystem(tenantId = 'master') {\n    return factSystem.createUserDB(`${tenantId}`);\n  };\n\n  return { getFactSystem };\n};\n\nconst setupFactSystem = function setupFactSystem(mongoURI, { clean, importData }, callback) {\n  // TODO: On a multitenanted system, importing data should not do anything\n  if (importData) {\n    return _sfacts2.default.load(mongoURI, importData, clean, (err, factSystem) => {\n      callback(err, decorateFactSystem(factSystem));\n    });\n  }\n  return _sfacts2.default.create(mongoURI, clean, (err, factSystem) => {\n    callback(err, decorateFactSystem(factSystem));\n  });\n};\n\nexports.default = {\n  setupFactSystem\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/chatSystem.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _gambit = require('./db/models/gambit');\n\nvar _gambit2 = _interopRequireDefault(_gambit);\n\nvar _reply = require('./db/models/reply');\n\nvar _reply2 = _interopRequireDefault(_reply);\n\nvar _topic = require('./db/models/topic');\n\nvar _topic2 = _interopRequireDefault(_topic);\n\nvar _user = require('./db/models/user');\n\nvar _user2 = _interopRequireDefault(_user);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n  I want to create a more organic approach to authoring new gambits, topics and replies.\n  Right now, the system parses flat files to a intermediate JSON object that SS reads and\n  creates an in-memory topic representation.\n\n  I believe by introducing a Topic DB with a clean API we can have a faster more robust authoring\n  expierence parseing input will become more intergrated into the topics, and Im propising\n  changing the existing parse inerface with a import/export to make sharing SuperScript\n  data (and advanced authoring?) easier.\n\n  We also want to put more focus on the Gambit, and less on topics. A Gambit should be\n  able to live in several topics.\n */\n\nconst setupChatSystem = function setupChatSystem(db, coreFactSystem, logger) {\n  const GambitCore = (0, _gambit2.default)(db, coreFactSystem);\n  const ReplyCore = (0, _reply2.default)(db);\n  const TopicCore = (0, _topic2.default)(db);\n  const UserCore = (0, _user2.default)(db, coreFactSystem, logger);\n\n  const getChatSystem = function getChatSystem(tenantId = 'master') {\n    const Gambit = GambitCore.byTenant(tenantId);\n    const Reply = ReplyCore.byTenant(tenantId);\n    const Topic = TopicCore.byTenant(tenantId);\n    const User = UserCore.byTenant(tenantId);\n\n    return {\n      Gambit,\n      Reply,\n      Topic,\n      User\n    };\n  };\n\n  return { getChatSystem };\n};\n\nexports.default = {\n  setupChatSystem\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/db/models/gambit.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _mongoose = require('mongoose');\n\nvar _mongoose2 = _interopRequireDefault(_mongoose);\n\nvar _mongoTenant = require('mongo-tenant');\n\nvar _mongoTenant2 = _interopRequireDefault(_mongoTenant);\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nvar _async = require('async');\n\nvar _async2 = _interopRequireDefault(_async);\n\nvar _ssParser = require('ss-parser');\n\nvar _ssParser2 = _interopRequireDefault(_ssParser);\n\nvar _modelNames = require('../modelNames');\n\nvar _modelNames2 = _interopRequireDefault(_modelNames);\n\nvar _utils = require('../../utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _debugLevels2.default)('SS:Gambit');\n\n/**\n  A trigger is the matching rule behind a piece of input. It lives in a topic or several topics.\n  A trigger also contains one or more replies.\n**/\n\n/**\n  A Gambit is a Trigger + Reply or Reply Set\n  - We define a Reply as a subDocument in Mongo.\n**/\n\nconst createGambitModel = function createGambitModel(db, factSystem) {\n  const gambitSchema = new _mongoose2.default.Schema({\n    id: { type: String, index: true, default: _utils2.default.genId() },\n\n    // This is the input string that generates a rule,\n    // In the event we want to export this, we will use this value.\n    // Make this filed conditionally required if trigger is supplied\n    input: { type: String },\n\n    // The Trigger is a partly baked regex.\n    trigger: { type: String },\n\n    // If the trigger is a Question Match\n    isQuestion: { type: Boolean, default: false },\n\n    // If this gambit is nested inside a conditional block\n    conditions: [{ type: String, default: '' }],\n\n    // The filter function for the the expression\n    filter: { type: String, default: '' },\n\n    // An array of replies.\n    replies: [{ type: String, ref: _modelNames2.default.reply }],\n\n    // How we choose gambits can be `random` or `ordered`\n    reply_order: { type: String, default: 'random' },\n\n    // How we handle the reply exhaustion can be `keep` or `exhaust`\n    reply_exhaustion: { type: String },\n\n    // Save a reference to the parent Reply, so we can walk back up the tree\n    parent: { type: String, ref: _modelNames2.default.reply },\n\n    // This will redirect anything that matches elsewhere.\n    // If you want to have a conditional rediect use reply redirects\n    // TODO, change the type to a ID and reference another gambit directly\n    // this will save us a lookup down the road (and improve performace.)\n    redirect: { type: String, default: '' }\n  });\n\n  gambitSchema.pre('save', function (next) {\n    // FIXME: This only works when the replies are populated which is not always the case.\n    // this.replies = _.uniq(this.replies, (item, key, id) => {\n    //   return item.id;\n    // });\n\n    // If we created the trigger in an external editor, normalize the trigger before saving it.\n    if (this.input && !this.trigger) {\n      const facts = factSystem.getFactSystem(this.getTenantId());\n      return _ssParser2.default.normalizeTrigger(this.input, facts, (err, cleanTrigger) => {\n        this.trigger = cleanTrigger;\n        next();\n      });\n    }\n    next();\n  });\n\n  gambitSchema.methods.addReply = function (replyData, callback) {\n    if (!replyData) {\n      return callback('No data');\n    }\n\n    const Reply = db.model(_modelNames2.default.reply).byTenant(this.getTenantId());\n    const reply = new Reply(replyData);\n    reply.save(err => {\n      if (err) {\n        return callback(err);\n      }\n      this.replies.addToSet(reply._id);\n      this.save(err => {\n        callback(err, reply);\n      });\n    });\n  };\n\n  gambitSchema.methods.clearReplies = function (callback) {\n    const self = this;\n\n    const clearReply = function clearReply(replyId, cb) {\n      self.replies.pull({ _id: replyId });\n      db.model(_modelNames2.default.reply).byTenant(this.getTenantId()).remove({ _id: replyId }, err => {\n        if (err) {\n          console.log(err);\n        }\n\n        debug.verbose('removed reply %s', replyId);\n\n        cb(null, replyId);\n      });\n    };\n\n    _async2.default.map(self.replies, clearReply, (err, clearedReplies) => {\n      self.save(err2 => {\n        callback(err2, clearedReplies);\n      });\n    });\n  };\n\n  gambitSchema.plugin(_mongoTenant2.default);\n\n  return db.model('ss_gambit', gambitSchema);\n};\n\nexports.default = createGambitModel;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/db/modelNames.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst names = {\n  gambit: 'ss_gambit',\n  reply: 'ss_reply',\n  topic: 'ss_topic',\n  user: 'ss_user'\n};\n\nexports.default = names;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/utils.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nvar _safeEval = require('safe-eval');\n\nvar _safeEval2 = _interopRequireDefault(_safeEval);\n\nvar _regexes = require('./regexes');\n\nvar _regexes2 = _interopRequireDefault(_regexes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst debug = (0, _debugLevels2.default)('SS:Utils');\n\n// TODO: rename to normlize to avoid confusion with string.trim() semantics\n/**\n * Remove extra whitespace from a string, while preserving new lines.\n * @param {string} text - the string to tidy up\n */\nconst trim = (text = '') => text.trim().replace(/[ \\t]+/g, ' ');\n\n/**\n * Count the number of real words in a string\n * @param {string} text - the text to count\n * @returns {number} the number of words in `text`\n */\nconst wordCount = text => text.split(/[\\s*#_|]+/).filter(w => w.length > 0).length;\n\n// Checks if any of the values in 'value' are present in 'list'\nconst inArray = function inArray(list, value) {\n  const values = _lodash2.default.isArray(value) ? value : [value];\n  return values.some(value => list.indexOf(value) >= 0);\n};\n\nconst commandsRE = /[\\\\.+?${}=!:]/g;\nconst nonCommandsRE = /[\\\\.+*?^\\[\\]$(){}=!<>|:]/g;\n/**\n * Escape a string sp that it can be used in a regular expression.\n * @param {string}  string   - the string to escape\n * @param {boolean} commands -\n */\nconst quotemeta = (string, commands = false) => string.replace(commands ? commandsRE : nonCommandsRE, c => `\\\\${c}`);\n\nconst getRandomInt = function getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst pickItem = function pickItem(arr) {\n  // TODO - Item may have a wornet suffix meal~2 or meal~n\n  const ind = getRandomInt(0, arr.length - 1);\n  return _lodash2.default.isString(arr[ind]) ? arr[ind].replace(/_/g, ' ') : arr[ind];\n};\n\nconst genId = function genId() {\n  let text = '';\n  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\n  for (let i = 0; i < 8; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n  return text;\n};\n\n/**\n * Search each string in `strings` for `<cap>` tags and replace them with values from `caps`.\n *\n * Replacement is positional so `<cap1>` replaces with `caps[1]` and so on, with `<cap>` also\n * replacing from `caps[1]`.\n * Empty `strings` are removed from the result.\n *\n * @param {Array<string>} strings - text to search for `<cap>` tags\n * @param {Array<string>} caps - replacement text\n */\nconst replaceCapturedText = (strings, caps) => strings.filter(s => !_lodash2.default.isEmpty(s)).map(s => s.replace(_regexes2.default.captures, (m, p1) => caps[Number.parseInt(p1 || 1)]));\n\nconst runPluginFunc = (() => {\n  var _ref = _asyncToGenerator(function* (functionRegex, scope, plugins) {\n    const pluginFunction = functionRegex.match(_regexes2.default.filter);\n    const functionName = pluginFunction[1];\n    const functionArgs = pluginFunction[2];\n\n    debug.verbose(`Running plugin function with name: ${functionName}`);\n\n    if (!plugins[functionName]) {\n      throw new Error(`Plugin function not found: ${functionName}`);\n    }\n\n    let cleanArgs = null;\n    try {\n      cleanArgs = (0, _safeEval2.default)(`[${functionArgs}]`);\n    } catch (err) {\n      throw new Error(`Error in plugin function arguments: ${err}`);\n    }\n\n    return new Promise(function (resolve, reject) {\n      cleanArgs.push(function (err, ...args) {\n        err ? reject(err) : resolve(args);\n      });\n      debug.verbose(`Calling plugin function: ${functionName} with args: ${cleanArgs}`);\n      plugins[functionName].apply(scope, cleanArgs);\n    });\n  });\n\n  function runPluginFunc(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  }\n\n  return runPluginFunc;\n})();\n\nexports.default = {\n  genId,\n  getRandomInt,\n  inArray,\n  pickItem,\n  quotemeta,\n  replaceCapturedText,\n  runPluginFunc,\n  trim,\n  wordCount\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/regexes.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// Standard regular expressions that can be reused throughout the codebase\n\nexports.default = {\n  captures: /<cap(\\d{0,2})>/ig,\n  delay: /{\\s*delay\\s*=\\s*(\\d+)\\s*}/,\n  filter: /\\^(\\w+)\\(([^)]*)\\)/i\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/db/models/reply.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _mongoose = require('mongoose');\n\nvar _mongoose2 = _interopRequireDefault(_mongoose);\n\nvar _mongoTenant = require('mongo-tenant');\n\nvar _mongoTenant2 = _interopRequireDefault(_mongoTenant);\n\nvar _async = require('async');\n\nvar _async2 = _interopRequireDefault(_async);\n\nvar _modelNames = require('../modelNames');\n\nvar _modelNames2 = _interopRequireDefault(_modelNames);\n\nvar _utils = require('../../utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _sort = require('../sort');\n\nvar _sort2 = _interopRequireDefault(_sort);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst createReplyModel = function createReplyModel(db) {\n  const replySchema = new _mongoose2.default.Schema({\n    id: { type: String, index: true, default: _utils2.default.genId() },\n    reply: { type: String, required: '{reply} is required.' },\n    keep: { type: Boolean, default: false },\n    filter: { type: String, default: '' },\n    parent: { type: String, ref: _modelNames2.default.gambit },\n\n    // Replies could referece other gambits\n    // This forms the basis for the 'previous' - These are Children\n    gambits: [{ type: String, ref: _modelNames2.default.gambit }]\n  });\n\n  replySchema.methods.sortGambits = function sortGambits(callback) {\n    const self = this;\n    const expandReorder = (gambitId, cb) => {\n      db.model(_modelNames2.default.gambit).byTenant(this.getTenantId()).findById(gambitId, (err, gambit) => {\n        cb(err, gambit);\n      });\n    };\n\n    _async2.default.map(this.gambits, expandReorder, (err, newGambitList) => {\n      if (err) {\n        console.log(err);\n      }\n\n      const newList = _sort2.default.sortTriggerSet(newGambitList);\n      self.gambits = newList.map(g => g._id);\n      self.save(callback);\n    });\n  };\n\n  replySchema.plugin(_mongoTenant2.default);\n\n  return db.model(_modelNames2.default.reply, replySchema);\n};\n\nexports.default = createReplyModel;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/db/sort.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _utils = require('../utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _debug2.default)('Sort');\n\nconst initSortTrack = function initSortTrack() {\n  return {\n    atomic: {}, // Sort by number of whole words\n    option: {}, // Sort optionals by number of words\n    alpha: {}, // Sort alpha wildcards by no. of words\n    number: {}, // Sort number wildcards by no. of words\n    wild: {}, // Sort wildcards by no. of words\n    pound: [], // Triggers of just #\n    under: [], // Triggers of just _\n    star: [] };\n};\n\nconst sortTriggerSet = function sortTriggerSet(gambits) {\n  let gambit;\n  let cnt;\n  let inherits;\n\n  const lengthSort = (a, b) => b.length - a.length;\n\n  // Create a priority map.\n  const prior = {\n    0: [] };\n\n  // Sort triggers by their weights.\n  for (let i = 0; i < gambits.length; i++) {\n    gambit = gambits[i];\n    const match = gambit.input.match(/\\{weight=(\\d+)\\}/i);\n    let weight = 0;\n    if (match && match[1]) {\n      weight = match[1];\n    }\n\n    if (!prior[weight]) {\n      prior[weight] = [];\n    }\n    prior[weight].push(gambit);\n  }\n\n  const sortFwd = (a, b) => b - a;\n  const sortRev = (a, b) => a - b;\n\n  // Keep a running list of sorted triggers for this topic.\n  const running = [];\n\n  // Sort them by priority.\n  const priorSort = Object.keys(prior).sort(sortFwd);\n\n  for (let i = 0; i < priorSort.length; i++) {\n    const p = priorSort[i];\n    debug(`Sorting triggers with priority ${p}`);\n\n    // Loop through and categorize these triggers.\n    const track = {};\n\n    for (let j = 0; j < prior[p].length; j++) {\n      gambit = prior[p][j];\n\n      inherits = -1;\n      if (!track[inherits]) {\n        track[inherits] = initSortTrack();\n      }\n\n      if (gambit.input.indexOf('*') > -1) {\n        // Wildcard included.\n        cnt = _utils2.default.wordCount(gambit.input);\n        debug(`Has a * wildcard with ${cnt} words.`);\n        if (cnt > 1) {\n          if (!track[inherits].wild[cnt]) {\n            track[inherits].wild[cnt] = [];\n          }\n          track[inherits].wild[cnt].push(gambit);\n        } else {\n          track[inherits].star.push(gambit);\n        }\n      } else if (gambit.input.indexOf('[') > -1) {\n        // Optionals included.\n        cnt = _utils2.default.wordCount(gambit.input);\n        debug(`Has optionals with ${cnt} words.`);\n        if (!track[inherits].option[cnt]) {\n          track[inherits].option[cnt] = [];\n        }\n        track[inherits].option[cnt].push(gambit);\n      } else {\n        // Totally atomic.\n        cnt = _utils2.default.wordCount(gambit.input);\n        debug(`Totally atomic trigger and ${cnt} words.`);\n        if (!track[inherits].atomic[cnt]) {\n          track[inherits].atomic[cnt] = [];\n        }\n        track[inherits].atomic[cnt].push(gambit);\n      }\n    }\n\n    // Move the no-{inherits} triggers to the bottom of the stack.\n    track[0] = track['-1'];\n    delete track['-1'];\n\n    // Add this group to the sort list.\n    const trackSorted = Object.keys(track).sort(sortRev);\n\n    for (let j = 0; j < trackSorted.length; j++) {\n      const ip = trackSorted[j];\n      debug(`ip=${ip}`);\n\n      const kinds = ['atomic', 'option', 'alpha', 'number', 'wild'];\n      for (let k = 0; k < kinds.length; k++) {\n        const kind = kinds[k];\n\n        const kindSorted = Object.keys(track[ip][kind]).sort(sortFwd);\n\n        for (let l = 0; l < kindSorted.length; l++) {\n          const item = kindSorted[l];\n          running.push(...track[ip][kind][item]);\n        }\n      }\n\n      // We can sort these using Array.sort\n      const underSorted = track[ip].under.sort(lengthSort);\n      const poundSorted = track[ip].pound.sort(lengthSort);\n      const starSorted = track[ip].star.sort(lengthSort);\n\n      running.push(...underSorted);\n      running.push(...poundSorted);\n      running.push(...starSorted);\n    }\n  }\n  return running;\n};\n\nexports.default = {\n  sortTriggerSet\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/db/models/topic.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _mongoose = require('mongoose');\n\nvar _mongoose2 = _interopRequireDefault(_mongoose);\n\nvar _mongoTenant = require('mongo-tenant');\n\nvar _mongoTenant2 = _interopRequireDefault(_mongoTenant);\n\nvar _async = require('async');\n\nvar _async2 = _interopRequireDefault(_async);\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nvar _modelNames = require('../modelNames');\n\nvar _modelNames2 = _interopRequireDefault(_modelNames);\n\nvar _sort = require('../sort');\n\nvar _sort2 = _interopRequireDefault(_sort);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n  Topics are a grouping of gambits.\n  The order of the Gambits are important, and a gambit can live in more than one topic.\n**/\n\nconst debug = (0, _debugLevels2.default)('SS:Topics');\n\nconst createTopicModel = function createTopicModel(db) {\n  const topicSchema = new _mongoose2.default.Schema({\n    name: { type: String, index: true, unique: true },\n\n    system: { type: Boolean, default: false },\n    nostay: { type: Boolean, default: false },\n    filter: { type: String, default: '' },\n    keywords: { type: Array },\n\n    // How we choose gambits can be `random` or `ordered`\n    reply_order: { type: String, default: 'random' },\n\n    // How we handle the reply exhaustion can be `keep` or `exhaust`\n    reply_exhaustion: { type: String },\n\n    gambits: [{ type: String, ref: _modelNames2.default.gambit }]\n  });\n\n  // This will create the Gambit and add it to the model\n  topicSchema.methods.createGambit = function (gambitData, callback) {\n    if (!gambitData) {\n      return callback('No data');\n    }\n\n    const Gambit = db.model(_modelNames2.default.gambit).byTenant(this.getTenantId());\n    const gambit = new Gambit(gambitData);\n    gambit.save(err => {\n      if (err) {\n        return callback(err);\n      }\n      this.gambits.addToSet(gambit._id);\n      this.save(err => {\n        callback(err, gambit);\n      });\n    });\n  };\n\n  topicSchema.methods.sortGambits = function (callback) {\n    const expandReorder = (gambitId, cb) => {\n      db.model(_modelNames2.default.gambit).byTenant(this.getTenantId()).findById(gambitId, (err, gambit) => {\n        if (err) {\n          console.log(err);\n        }\n        cb(null, gambit);\n      });\n    };\n\n    _async2.default.map(this.gambits, expandReorder, (err, newGambitList) => {\n      if (err) {\n        console.log(err);\n      }\n\n      const newList = _sort2.default.sortTriggerSet(newGambitList);\n      this.gambits = newList.map(gambit => gambit._id);\n      this.save(callback);\n    });\n  };\n\n  topicSchema.methods.clearGambits = function (callback) {\n    const clearGambit = (gambitId, cb) => {\n      this.gambits.pull({ _id: gambitId });\n      db.model(_modelNames2.default.gambit).byTenant(this.getTenantId()).findById(gambitId, (err, gambit) => {\n        if (err) {\n          debug.error(err);\n        }\n\n        gambit.clearReplies(() => {\n          db.model(_modelNames2.default.gambit).byTenant(this.getTenantId()).remove({ _id: gambitId }, err => {\n            if (err) {\n              debug.error(err);\n            }\n\n            debug.verbose('removed gambit %s', gambitId);\n\n            cb(null, gambitId);\n          });\n        });\n      });\n    };\n\n    _async2.default.map(this.gambits, clearGambit, (err, clearedGambits) => {\n      this.save(err => {\n        callback(err, clearedGambits);\n      });\n    });\n  };\n\n  topicSchema.statics.findByName = function (name, callback) {\n    this.findOne({ name }, {}, callback);\n  };\n\n  topicSchema.plugin(_mongoTenant2.default);\n\n  return db.model(_modelNames2.default.topic, topicSchema);\n};\n\nexports.default = createTopicModel;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/db/models/user.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nvar _mongoose = require('mongoose');\n\nvar _mongoose2 = _interopRequireDefault(_mongoose);\n\nvar _mongoTenant = require('mongo-tenant');\n\nvar _mongoTenant2 = _interopRequireDefault(_mongoTenant);\n\nvar _modelNames = require('../modelNames');\n\nvar _modelNames2 = _interopRequireDefault(_modelNames);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst debug = (0, _debugLevels2.default)('SS:User');\n\nconst createUserModel = function createUserModel(db, factSystem, logger) {\n  const userSchema = _mongoose2.default.Schema({\n    id: String,\n    currentTopic: { type: String, default: 'random' },\n    pendingTopic: String,\n    lastMessageSentAt: Date,\n    prevAns: Number,\n    conversationState: Object,\n    history: [{\n      input: Object,\n      reply: Object,\n      topic: Object,\n      stars: Object\n    }]\n  });\n\n  userSchema.pre('save', function (next) {\n    debug.verbose('Pre-Save Hook');\n    // save a full log of user conversations, but just in case a user has a\n    // super long conversation, don't take up too much storage space\n    this.history = this.history.slice(0, 500);\n    next();\n  });\n\n  userSchema.methods.clearConversationState = function (callback) {\n    this.conversationState = {};\n    this.save(callback);\n  };\n\n  userSchema.methods.setTopic = (() => {\n    var _ref = _asyncToGenerator(function* (topic = '') {\n      debug.verbose('Set topic', topic);\n\n      if (topic === '') {\n        debug.warn('Trying to set topic to something invalid');\n        return;\n      }\n\n      this.pendingTopic = topic;\n      yield this.save();\n      debug.verbose('Set topic Complete');\n    });\n\n    return function () {\n      return _ref.apply(this, arguments);\n    };\n  })();\n\n  userSchema.methods.getTopic = function () {\n    debug.verbose('getTopic', this.currentTopic);\n    return this.currentTopic;\n  };\n\n  userSchema.methods.updateHistory = function (message, reply, cb) {\n    if (!_lodash2.default.isNull(message)) {\n      this.lastMessageSentAt = Date.now();\n    }\n\n    const log = {\n      user_id: this.id,\n      raw_input: message.original,\n      normalized_input: message.clean,\n      matched_gambit: reply.debug,\n      final_output: reply.original,\n      timestamp: message.createdAt\n    };\n\n    const cleanId = this.id.replace(/\\W/g, '');\n    logger.log(`${JSON.stringify(log)}\\r\\n`, `${cleanId}_trans.txt`);\n\n    debug.verbose('Updating History');\n\n    const stars = reply.stars;\n\n    const messageToSave = {\n      original: message.original,\n      clean: message.clean,\n      timestamp: message.createdAt\n    };\n\n    reply.createdAt = Date.now();\n\n    this.history.unshift({\n      stars,\n      input: messageToSave,\n      reply,\n      topic: this.currentTopic\n    });\n\n    if (this.pendingTopic !== undefined && this.pendingTopic !== '') {\n      const pendingTopic = this.pendingTopic;\n      this.pendingTopic = null;\n\n      db.model(_modelNames2.default.topic).byTenant(this.getTenantId()).findOne({ name: pendingTopic }, (err, topicData) => {\n        if (topicData && topicData.nostay === true) {\n          this.currentTopic = this.history[0].topic;\n        } else {\n          this.currentTopic = pendingTopic;\n        }\n        this.save(err => {\n          if (err) {\n            console.error(err);\n          }\n          debug.verbose('Saved user');\n          cb(err, log);\n        });\n      });\n    } else {\n      cb(null, log);\n    }\n  };\n\n  userSchema.methods.getVar = function (key, cb) {\n    debug.verbose('getVar', key);\n\n    this.memory.db.get({ subject: key, predicate: this.id }, (err, res) => {\n      if (res && res.length !== 0) {\n        cb(err, res[0].object);\n      } else {\n        cb(err, null);\n      }\n    });\n  };\n\n  userSchema.methods.setVar = function (key, value, cb) {\n    debug.verbose('setVar', key, value);\n    const self = this;\n\n    self.memory.db.get({ subject: key, predicate: self.id }, (err, results) => {\n      if (err) {\n        console.log(err);\n      }\n\n      if (!_lodash2.default.isEmpty(results)) {\n        self.memory.db.del(results[0], () => {\n          const opt = { subject: key, predicate: self.id, object: value };\n          self.memory.db.put(opt, () => {\n            cb();\n          });\n        });\n      } else {\n        const opt = { subject: key, predicate: self.id, object: value };\n        self.memory.db.put(opt, err2 => {\n          if (err2) {\n            console.log(err2);\n          }\n\n          cb();\n        });\n      }\n    });\n  };\n\n  userSchema.plugin(_mongoTenant2.default);\n\n  userSchema.virtual('memory').get(function () {\n    return factSystem.getFactSystem(this.getTenantId()).createUserDB(this.id);\n  });\n\n  return db.model(_modelNames2.default.user, userSchema);\n};\n\nexports.default = createUserModel;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/getReply/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nvar _utils = require('../utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _processTags = require('../processTags');\n\nvar _processTags2 = _interopRequireDefault(_processTags);\n\nvar _getPendingTopics = require('./getPendingTopics');\n\nvar _getPendingTopics2 = _interopRequireDefault(_getPendingTopics);\n\nvar _filterFunction = require('./filterFunction');\n\nvar _filterFunction2 = _interopRequireDefault(_filterFunction);\n\nvar _filterSeen = require('./filterSeen');\n\nvar _filterSeen2 = _interopRequireDefault(_filterSeen);\n\nvar _processReplyTags = require('./processReplyTags');\n\nvar _processReplyTags2 = _interopRequireDefault(_processReplyTags);\n\nvar _helpers = require('./helpers');\n\nvar _helpers2 = _interopRequireDefault(_helpers);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } /* eslint-disable no-use-before-define */\n\nconst debug = (0, _debugLevels2.default)('SS:GetReply');\n\n/**\n * The real craziness to retreive a reply.\n * @param {Object} messageObject - The instance of the Message class for the user input.\n * @param {Object} options.system - The system.\n * @param {Object} options.user - The user.\n * @param {Number} options.depth - The depth of how many times this function has been recursively called.\n * @param {Array} options.pendingTopics - A list of topics that have been specified to specifically search (usually via topicRedirect etc).\n * @param {Function} callback - Callback function once the reply has been found.\n */\nconst getReply = (() => {\n  var _ref = _asyncToGenerator(function* (messageObject, options, callback) {\n    if (options.depth) {\n      debug.verbose('Called recursively', options.depth);\n      if (options.depth >= 20) {\n        console.error('getReply was called recursively 20 times - returning null reply.');\n        return callback(null, null);\n      }\n    }\n\n    let matches = [];\n    try {\n      const pendingTopics = yield (0, _getPendingTopics2.default)(messageObject, options);\n      matches = yield findMatches(pendingTopics, messageObject, options);\n    } catch (err) {\n      console.error(err);\n    }\n\n    const data = afterHandle(matches);\n    // One day, everything will be async/await and everything will be happy. Until\n    // then, catch exceptions in the callback and throw them at top-level on next tick.\n    try {\n      return callback(null, data);\n    } catch (err) {\n      process.nextTick(function () {\n        throw err;\n      });\n    }\n  });\n\n  function getReply(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  }\n\n  return getReply;\n})();\n\nconst findMatches = (() => {\n  var _ref2 = _asyncToGenerator(function* (pendingTopics, messageObject, options) {\n    debug.verbose(`Found pending topics/conversations: ${JSON.stringify(pendingTopics)}`);\n\n    const replies = [];\n    let stopSearching = false;\n\n    // We use a for loop here because we can break on finding a reply.\n    // The error is our escape hatch when we have a reply WITH data.\n    for (let i = 0; i < pendingTopics.length && !stopSearching; ++i) {\n      const topic = pendingTopics[i];\n      let unfilteredMatches = yield topicItorHandle(topic, messageObject, options);\n\n      // Remove the empty topics, and flatten the array down.\n      unfilteredMatches = _lodash2.default.flatten(_lodash2.default.filter(unfilteredMatches, function (n) {\n        return n;\n      }));\n\n      debug.info('Matching unfiltered gambits are: ');\n      unfilteredMatches.forEach(function (match) {\n        debug.info(`Trigger: ${match.gambit.input}`);\n        debug.info(`Replies: ${match.gambit.replies.map(function (reply) {\n          return reply.reply;\n        }).join('\\n')}`);\n      });\n\n      for (let j = 0; j < unfilteredMatches.length && !stopSearching; ++j) {\n        const match = unfilteredMatches[j];\n        const reply = yield matchItorHandle(match, messageObject, options);\n\n        if (!_lodash2.default.isEmpty(reply)) {\n          replies.push(reply);\n          if (reply.continueMatching === false) {\n            debug.info('Continue matching is set to false: returning.');\n            stopSearching = true;\n          } else if (reply.continueMatching === true || reply.reply.reply === '') {\n            debug.info('Continue matching is set to true or reply is empty: continuing.');\n          } else {\n            debug.info('Reply is not empty: returning.');\n            stopSearching = true;\n          }\n        }\n      }\n    }\n\n    return replies;\n  });\n\n  function findMatches(_x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  }\n\n  return findMatches;\n})();\n\n// Topic iterator, we call this on each topic or conversation reply looking for a match.\n// All the matches are stored and returned in the callback.\nconst topicItorHandle = (() => {\n  var _ref3 = _asyncToGenerator(function* (topicData, messageObject, options) {\n    const system = options.system;\n\n    if (topicData.type === 'TOPIC') {\n      const topic = yield system.chatSystem.Topic.findById(topicData.id, '_id name filter gambits').populate({ path: 'gambits', populate: { path: 'replies' } }).lean().exec();\n      if (topic) {\n        // We do realtime post processing on the input against the user object\n        if (topic.filter) {\n          debug.verbose(`Topic filter function found: ${topic.filter}`);\n\n          const filterScope = _lodash2.default.merge({}, system.scope);\n          filterScope.user = options.user;\n          filterScope.message = messageObject;\n          filterScope.topic = topic;\n          filterScope.message_props = options.system.extraScope;\n\n          try {\n            var _ref4 = yield _utils2.default.runPluginFunc(topic.filter, filterScope, system.plugins),\n                _ref5 = _slicedToArray(_ref4, 1);\n\n            const filterReply = _ref5[0];\n\n            if (filterReply === 'true' || filterReply === true) {\n              return false;\n            }\n          } catch (err) {\n            console.error(err);\n            return false;\n          }\n        }\n\n        options.topic = topic.name;\n        return _helpers2.default.findMatchingGambitsForMessage('topic', topic, messageObject, options);\n      }\n      // We call back if there is no topic Object\n      // Non-existant topics return false\n      return false;\n    } else if (topicData.type === 'REPLY') {\n      const reply = yield system.chatSystem.Reply.findById(topicData.id, '_id name filter gambits').populate({ path: 'gambits', populate: { path: 'replies' } }).lean().exec();\n      debug.verbose('Conversation reply thread: ', reply);\n      if (reply) {\n        return _helpers2.default.findMatchingGambitsForMessage('reply', reply, messageObject, options);\n      }\n      return false;\n    }\n\n    debug.verbose(\"We shouldn't hit this! 'topicData.type' should be 'TOPIC' or 'REPLY'\");\n    return false;\n  });\n\n  function topicItorHandle(_x7, _x8, _x9) {\n    return _ref3.apply(this, arguments);\n  }\n\n  return topicItorHandle;\n})();\n\n// Iterates through matched gambits\nconst matchItorHandle = (() => {\n  var _ref6 = _asyncToGenerator(function* (match, message, options) {\n    const system = options.system;\n    options.message = message;\n\n    debug.verbose('Match itor: ', match.gambit);\n\n    const topic = yield _helpers2.default.getRootTopic(match.gambit, system.chatSystem);\n\n    let stars = match.stars;\n    if (!_lodash2.default.isEmpty(message.stars)) {\n      stars = message.stars;\n    }\n\n    const potentialReplies = [];\n\n    for (let i = 0; i < match.gambit.replies.length; i++) {\n      const reply = match.gambit.replies[i];\n      const replyData = {\n        id: reply.id,\n        topic: topic.name,\n        stars,\n        reply,\n\n        // For the logs\n        trigger: match.gambit.input,\n        trigger_id: match.gambit.id,\n        trigger_id2: match.gambit._id\n      };\n      potentialReplies.push(replyData);\n    }\n\n    // Find a reply for the match.\n    let filtered = yield (0, _filterFunction2.default)(potentialReplies, options);\n    filtered = yield (0, _filterSeen2.default)(filtered, options);\n\n    const pickScheme = match.gambit.reply_order;\n\n    debug.verbose('Filtered Results', filtered);\n    debug.verbose('Pick Scheme:', pickScheme);\n\n    debug.verbose('Default Keep', options.system.defaultKeepScheme);\n    debug.verbose('Topic Keep', topic.reply_exhaustion);\n    debug.verbose('Gambit Keep', match.gambit.reply_exhaustion);\n\n    let keepScheme = options.system.defaultKeepScheme;\n    if (match.gambit.reply_exhaustion) {\n      keepScheme = match.gambit.reply_exhaustion;\n    } else if (topic.reply_exhaustion) {\n      keepScheme = topic.reply_exhaustion;\n    }\n\n    let filteredNew = [];\n    debug.verbose('Using KeepScheme', keepScheme);\n\n    if (keepScheme === 'exhaust' || keepScheme === 'reload') {\n      filteredNew = _lodash2.default.filter(filtered, function (reply) {\n        return reply.seenCount === 0 || reply.reply.keep;\n      });\n    }\n\n    // We reload the replies if we have nothing else to show.\n    if (keepScheme === 'reload' && _lodash2.default.isEmpty(filteredNew)) {\n      debug.verbose('Reloading Replies');\n      filteredNew = filtered;\n    } else if (keepScheme === 'keep') {\n      filteredNew = filtered;\n    }\n\n    // Orderd or Random\n    const picked = pickScheme === 'ordered' ? filteredNew.shift() : _utils2.default.pickItem(filteredNew);\n\n    // If we have an item lets use it, otherwise retutn null and keep matching.\n    debug.verbose('Picked', picked);\n    return picked ? (0, _processReplyTags2.default)(picked, options) : null;\n  });\n\n  function matchItorHandle(_x10, _x11, _x12) {\n    return _ref6.apply(this, arguments);\n  }\n\n  return matchItorHandle;\n})();\n\nconst afterHandle = function afterHandle(matches) {\n  debug.verbose(`Set of matches: ${matches}`);\n\n  const debugAll = [];\n  let props = {};\n  let clearConversation = false;\n  let lastTopicToMatch = null;\n  let lastStarSet = null;\n  let lastReplyId = null;\n  let replyString = '';\n  let lastSubReplies = null;\n  let lastContinueMatching = null;\n  let lastReplyIds = null;\n\n  matches.forEach(match => {\n    const debugMatch = {\n      topic: match.matched_topic_string || match.topic,\n      input: match.trigger,\n      reply: match.matched_reply_string\n    };\n\n    if (!_lodash2.default.isEmpty(match.debug)) {\n      debugMatch.subset = match.debug;\n    } else {\n      debugMatch.output = match.reply.reply;\n    }\n\n    debugAll.push(debugMatch);\n\n    if (match.reply && match.reply.reply) {\n      if (replyString === '') {\n        replyString += `${match.reply.reply}`;\n      } else {\n        replyString += ` ${match.reply.reply}`;\n      }\n    }\n\n    props = _lodash2.default.assign(props, match.props);\n    lastTopicToMatch = match.topic;\n    lastStarSet = match.stars;\n    lastReplyId = match.reply._id;\n    lastSubReplies = match.subReplies;\n    lastContinueMatching = match.continueMatching;\n    lastReplyIds = match.replyIds;\n\n    if (match.clearConversation) {\n      clearConversation = match.clearConversation;\n    }\n  });\n\n  let threadsArr = [];\n  if (_lodash2.default.isEmpty(lastSubReplies)) {\n    threadsArr = _processTags2.default.processThreadTags(replyString);\n  } else {\n    threadsArr[0] = replyString;\n    threadsArr[1] = lastSubReplies;\n  }\n\n  const data = {\n    replyId: lastReplyId,\n    replyIds: lastReplyIds,\n    props,\n    clearConversation,\n    topicName: lastTopicToMatch,\n    debug: debugAll,\n    string: threadsArr[0],\n    subReplies: threadsArr[1],\n    stars: lastStarSet,\n    continueMatching: lastContinueMatching\n  };\n\n  debug.verbose('afterHandle', data);\n\n  return data;\n};\n\nexports.default = getReply;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/processTags.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nvar _pegjs = require('pegjs');\n\nvar _pegjs2 = _interopRequireDefault(_pegjs);\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _safeEval = require('safe-eval');\n\nvar _safeEval2 = _interopRequireDefault(_safeEval);\n\nvar _utils = require('./utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _regexes = require('./regexes');\n\nvar _regexes2 = _interopRequireDefault(_regexes);\n\nvar _wordnet = require('./reply/wordnet');\n\nvar _wordnet2 = _interopRequireDefault(_wordnet);\n\nvar _inlineRedirect = require('./reply/inlineRedirect');\n\nvar _inlineRedirect2 = _interopRequireDefault(_inlineRedirect);\n\nvar _topicRedirect = require('./reply/topicRedirect');\n\nvar _topicRedirect2 = _interopRequireDefault(_topicRedirect);\n\nvar _respond = require('./reply/respond');\n\nvar _respond2 = _interopRequireDefault(_respond);\n\nvar _customFunction = require('./reply/customFunction');\n\nvar _customFunction2 = _interopRequireDefault(_customFunction);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } // TODO: Fix this documentation, options is incorrect\n/**\n * Parse the reply for additional tags, this is called once we have a reply candidate filtered out.\n *\n * @param {Object} replyObj - The Reply Object\n * @param {string} replyObj.id - This is the 8 digit id mapping back to the ss parsed json\n * @param {array} replyObj.stars - All of the matched values\n * @param {string} replyObj.topic - The Topic name we matched on\n * @param {Object} replyObj.reply - This is the Mongo Reply Gambit\n * @param {string} replyObj.trigger - The input string of the gambit the user matched with their message\n * @param {string} replyObj.trigger_id - The trigger id (8 digit)\n * @param {string} replyObj.trigger_id2 - The trigger id (mongo id)\n *\n * @param {Object} options\n * @param {Object} options.user - The user object\n * @param {Object} options.system - Extra cached items that are loaded async during load-time\n * @param {Object} options.message - The original message object\n *\n * @param {array} options.system.plugins - An array of plugins loaded from the plugin folder\n * @param {Object} options.system.scope - All of the data available to `this` inside of the plugin during execution\n * @param {number} options.depth - Counter of how many times this function is called recursively.\n *\n * Replies can have the following:\n * Basic (captured text) subsitution ie: `I like <cap1>`\n * Input (parts of speech) subsitution ie: `I like <noun>`\n * Expanding terms using wordnet ie: `I like ~sport`\n * Alternate terms to choose at random ie: `I like (baseball|hockey)`\n * Custom functions that can be called ie: `I like ^chooseSport()`\n * Redirects to another reply ie: `I like {@sport}`\n */\n\nconst debug = (0, _debugLevels2.default)('SS:ProcessTags');\n\nconst grammar = _fs2.default.readFileSync(`${__dirname}/reply/reply-grammar.pegjs`, 'utf-8');\n// Change trace to true to debug peg\nconst parser = _pegjs2.default.generate(grammar, { trace: false });\n\nconst preprocessGrammar = _fs2.default.readFileSync(`${__dirname}/reply/preprocess-grammar.pegjs`, 'utf-8');\n// Change trace to true to debug peg\nconst preprocessParser = _pegjs2.default.generate(preprocessGrammar, { trace: false });\n\n/* topicRedirect\n/ respond\n/ redirect\n/ customFunction\n/ newTopic\n/ capture\n/ previousCapture\n/ clearConversation\n/ continueSearching\n/ endSearching\n/ previousInput\n/ previousReply\n/ wordnetLookup\n/ alternates\n/ delay\n/ setState\n/ string*/\n\nconst processCapture = function processCapture(tag, replyObj, options) {\n  const starID = (tag.starID || 1) - 1;\n  debug.verbose(`Processing capture: <cap${starID + 1}>`);\n  const replacedCapture = starID < replyObj.stars.length ? replyObj.stars[starID] : '';\n  debug.verbose(`Replacing <cap${starID + 1}> with \"${replacedCapture}\"`);\n  return replacedCapture;\n};\n\nconst processPreviousCapture = function processPreviousCapture(tag, replyObj, options) {\n  // This is to address GH-207, pulling the stars out of the history and\n  // feeding them forward into new replies. It allows us to save a tiny bit of\n  // context though a conversation cycle.\n  // TODO: handle captures within captures, but only 1 level deep\n  const starID = (tag.starID || 1) - 1;\n  const conversationID = (tag.conversationID || 1) - 1;\n  debug.verbose(`Processing previous capture: <p${conversationID + 1}cap${starID + 1}>`);\n  let replacedCapture = '';\n\n  if (options.user.history[conversationID].stars && options.user.history[conversationID].stars[starID]) {\n    replacedCapture = options.user.history[conversationID].stars[starID];\n    debug.verbose(`Replacing <p${conversationID + 1}cap${starID + 1}> with \"${replacedCapture}\"`);\n  } else {\n    debug.verbose('Attempted to use previous capture data, but none was found in user history.');\n  }\n  return replacedCapture;\n};\n\nconst processPreviousInput = function processPreviousInput(tag, replyObj, options) {\n  if (tag.inputID === null) {\n    debug.verbose('Processing previous input <input>');\n    // This means <input> instead of <input1>, <input2> etc. so give the current input back\n    const replacedInput = options.message.clean;\n    return replacedInput;\n  }\n\n  const inputID = (tag.inputID || 1) - 1;\n  debug.verbose(`Processing previous input <input${inputID + 1}>`);\n  let replacedInput = '';\n  if (options.user.history.length === 0) {\n    // Nothing yet in the history\n    replacedInput = '';\n  } else {\n    replacedInput = options.user.history[inputID].input.original;\n  }\n  debug.verbose(`Replacing <input${inputID + 1}> with \"${replacedInput}\"`);\n  return replacedInput;\n};\n\nconst processPreviousReply = function processPreviousReply(tag, replyObj, options) {\n  const replyID = (tag.replyID || 1) - 1;\n  debug.verbose(`Processing previous reply <reply${replyID + 1}>`);\n  let replacedReply = '';\n  if (options.user.history === 0) {\n    // Nothing yet in the history\n    replacedReply = '';\n  } else {\n    replacedReply = options.user.history[replyID].reply;\n  }\n  debug.verbose(`Replacing <reply{replyID + 1}> with \"${replacedReply}\"`);\n  return replacedReply;\n};\n\nconst processWordnetLookup = (() => {\n  var _ref = _asyncToGenerator(function* (tag, replyObj, options) {\n    debug.verbose(`Processing wordnet lookup for word: ~${tag.term}`);\n    let words = yield _wordnet2.default.lookup(tag.term, '~');\n    words = words.map(function (item) {\n      return item.replace(/_/g, ' ');\n    });\n    debug.verbose(`Terms found in wordnet: ${words}`);\n\n    const replacedWordnet = _utils2.default.pickItem(words);\n    debug.verbose(`Wordnet replaced term: ${replacedWordnet}`);\n    return replacedWordnet;\n  });\n\n  function processWordnetLookup(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  }\n\n  return processWordnetLookup;\n})();\n\n// Replacements are captures or wordnet lookups\nconst processReplacement = (() => {\n  var _ref2 = _asyncToGenerator(function* (tag, replyObj, options) {\n    switch (tag.type) {\n      case 'capture':\n        {\n          return processCapture(tag, replyObj, options);\n        }\n      case 'previousCapture':\n        {\n          return processPreviousCapture(tag, replyObj, options);\n        }\n      case 'previousInput':\n        {\n          return processPreviousInput(tag, replyObj, options);\n        }\n      case 'previousReply':\n        {\n          return processPreviousReply(tag, replyObj, options);\n        }\n      case 'wordnetLookup':\n        {\n          return processWordnetLookup(tag, replyObj, options);\n        }\n      default:\n        {\n          throw new Error(`Replacement tag type does not exist: ${tag.type}`);\n        }\n    }\n  });\n\n  function processReplacement(_x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  }\n\n  return processReplacement;\n})();\n\nconst preprocess = (() => {\n  var _ref3 = _asyncToGenerator(function* (reply, replyObj, options) {\n    let captureTags = preprocessParser.parse(reply);\n    captureTags = _lodash2.default.flattenDeep(captureTags);\n    const cleanTags = yield Promise.all(captureTags.map((() => {\n      var _ref4 = _asyncToGenerator(function* (tag) {\n        // Don't do anything to non-captures/wordnet terms\n        if (typeof tag === 'string') {\n          return tag;\n        }\n        // It's a capture or wordnet lookup e.g. <cap2> or ~like, so replace it with\n        // the captured star in replyObj.stars or a random selection of wordnet term\n        const replacement = yield processReplacement(tag, replyObj, options);\n        return `\"${replacement}\"`;\n      });\n\n      return function (_x10) {\n        return _ref4.apply(this, arguments);\n      };\n    })()));\n    return cleanTags.join('');\n  });\n\n  function preprocess(_x7, _x8, _x9) {\n    return _ref3.apply(this, arguments);\n  }\n\n  return preprocess;\n})();\n\nconst postAugment = function postAugment(replyObject, augmentedReplyObject) {\n  replyObject.continueMatching = augmentedReplyObject.continueMatching;\n  replyObject.clearConversation = replyObject.clearConversation || augmentedReplyObject.clearConversation;\n  replyObject.topic = augmentedReplyObject.topicName;\n  replyObject.props = _lodash2.default.merge(replyObject.props, augmentedReplyObject.props);\n\n  // Keep track of all the ids of all the triggers we go through via redirects\n  if (augmentedReplyObject.replyIds) {\n    augmentedReplyObject.replyIds.forEach(replyId => {\n      replyObject.replyIds.push(replyId);\n    });\n  }\n\n  if (augmentedReplyObject.subReplies) {\n    if (replyObject.subReplies) {\n      replyObject.subReplies = replyObject.subReplies.concat(augmentedReplyObject.subReplies);\n    } else {\n      replyObject.subReplies = augmentedReplyObject.subReplies;\n    }\n  }\n\n  replyObject.debug = augmentedReplyObject.debug;\n  return augmentedReplyObject.string;\n};\n\nconst processTopicRedirect = (() => {\n  var _ref5 = _asyncToGenerator(function* (tag, replyObj, options) {\n    let cleanedArgs = null;\n    try {\n      cleanedArgs = (0, _safeEval2.default)(tag.functionArgs);\n    } catch (err) {\n      throw new Error(`Error processing topicRedirect args: ${err}`);\n    }\n\n    const topicName = cleanedArgs[0];\n    const topicTrigger = cleanedArgs[1];\n\n    debug.verbose(`Processing topic redirect ^topicRedirect(${topicName},${topicTrigger})`);\n    options.depth += 1;\n    const augmentedReplyObject = yield (0, _topicRedirect2.default)(topicName, topicTrigger, options);\n    return postAugment(replyObj, augmentedReplyObject);\n  });\n\n  function processTopicRedirect(_x11, _x12, _x13) {\n    return _ref5.apply(this, arguments);\n  }\n\n  return processTopicRedirect;\n})();\n\nconst processRespond = (() => {\n  var _ref6 = _asyncToGenerator(function* (tag, replyObj, options) {\n    let cleanedArgs = null;\n    try {\n      cleanedArgs = (0, _safeEval2.default)(tag.functionArgs);\n    } catch (err) {\n      throw new Error(`Error processing respond args: ${err}`);\n    }\n\n    const topicName = cleanedArgs[0];\n\n    debug.verbose(`Processing respond: ^respond(${topicName})`);\n    options.depth += 1;\n    const augmentedReplyObject = yield (0, _respond2.default)(topicName, options);\n    return postAugment(replyObj, augmentedReplyObject);\n  });\n\n  function processRespond(_x14, _x15, _x16) {\n    return _ref6.apply(this, arguments);\n  }\n\n  return processRespond;\n})();\n\nconst processRedirect = (() => {\n  var _ref7 = _asyncToGenerator(function* (tag, replyObj, options) {\n    debug.verbose(`Processing inline redirect: {@${tag.trigger}}`);\n    options.depth += 1;\n    const augmentedReplyObject = yield (0, _inlineRedirect2.default)(tag.trigger, options);\n    return postAugment(replyObj, augmentedReplyObject);\n  });\n\n  function processRedirect(_x17, _x18, _x19) {\n    return _ref7.apply(this, arguments);\n  }\n\n  return processRedirect;\n})();\n\nconst processCustomFunction = (() => {\n  var _ref8 = _asyncToGenerator(function* (tag, replyObj, options) {\n    if (tag.functionArgs === null) {\n      debug.verbose(`Processing custom function: ^${tag.functionName}()`);\n      return (0, _customFunction2.default)(tag.functionName, [], replyObj, options);\n    }\n\n    let cleanArgs = null;\n    try {\n      cleanArgs = (0, _safeEval2.default)(tag.functionArgs);\n    } catch (e) {\n      throw new Error(`Error processing custom function arguments: ${e}`);\n    }\n\n    const response = yield (0, _customFunction2.default)(tag.functionName, cleanArgs, replyObj, options);\n    // The custom function might return something with more tags, so do it all again\n    let preprocessed;\n    try {\n      preprocessed = yield preprocess(response, replyObj, options);\n    } catch (err) {\n      throw new Error(`There was an error preprocessing reply tags: ${err}`);\n    }\n\n    const replyTags = parser.parse(preprocessed);\n\n    try {\n      const processedReplyParts = yield Promise.all(replyTags.map((() => {\n        var _ref9 = _asyncToGenerator(function* (tag) {\n          return processTag(tag, replyObj, options);\n        });\n\n        return function (_x23) {\n          return _ref9.apply(this, arguments);\n        };\n      })()));\n      return processedReplyParts.join('').trim();\n    } catch (err) {\n      throw new Error(`There was an error processing reply tags: ${err}`);\n    }\n  });\n\n  function processCustomFunction(_x20, _x21, _x22) {\n    return _ref8.apply(this, arguments);\n  }\n\n  return processCustomFunction;\n})();\n\nconst processNewTopic = (() => {\n  var _ref10 = _asyncToGenerator(function* (tag, replyObj, options) {\n    debug.verbose(`Processing new topic: ${tag.topicName}`);\n    const newTopic = tag.topicName;\n    yield options.user.setTopic(newTopic);\n    return '';\n  });\n\n  function processNewTopic(_x24, _x25, _x26) {\n    return _ref10.apply(this, arguments);\n  }\n\n  return processNewTopic;\n})();\n\nconst processClearConversation = function processClearConversation(tag, replyObj, options) {\n  debug.verbose('Processing clear conversation: setting clear conversation to true');\n  replyObj.clearConversation = true;\n  return '';\n};\n\nconst processContinueSearching = function processContinueSearching(tag, replyObj, options) {\n  debug.verbose('Processing continue searching: setting continueMatching to true');\n  replyObj.continueMatching = true;\n  return '';\n};\n\nconst processEndSearching = function processEndSearching(tag, replyObj, options) {\n  debug.verbose('Processing end searching: setting continueMatching to false');\n  replyObj.continueMatching = false;\n  return '';\n};\n\nconst processAlternates = function processAlternates(tag, replyObj, options) {\n  debug.verbose(`Processing alternates: ${tag.alternates}`);\n  const alternates = tag.alternates;\n  const random = _utils2.default.getRandomInt(0, alternates.length - 1);\n  const result = alternates[random];\n  return result;\n};\n\nconst processDelay = function processDelay(tag, replyObj, options) {\n  return `{delay=${tag.delayLength}}`;\n};\n\nconst processSetState = function processSetState(tag, replyObj, options) {\n  debug.verbose(`Processing setState: ${JSON.stringify(tag.stateToSet)}`);\n  const stateToSet = tag.stateToSet;\n  const newState = {};\n  stateToSet.forEach(keyValuePair => {\n    const key = keyValuePair.key;\n    let value = keyValuePair.value;\n\n    // Value is a string\n    value = value.replace(/[\"']/g, '');\n\n    // Value is an integer\n    if (/^[\\d]+$/.test(value)) {\n      value = +value;\n    }\n\n    // Value is a boolean\n    if (value === 'true') {\n      value = true;\n    } else if (value === 'false') {\n      value = false;\n    }\n\n    newState[key] = value;\n  });\n  debug.verbose(`New state: ${JSON.stringify(newState)}`);\n  options.user.conversationState = _lodash2.default.merge(options.user.conversationState, newState);\n  options.user.markModified('conversationState');\n  return '';\n};\n\nconst processTag = (() => {\n  var _ref11 = _asyncToGenerator(function* (tag, replyObj, options) {\n    if (typeof tag === 'string') {\n      return tag;\n    }\n\n    const tagType = tag.type;\n    switch (tagType) {\n      case 'capture':\n      case 'previousCapture':\n      case 'previousInput':\n      case 'previousReply':\n      case 'wordnetLookup':\n        {\n          return processReplacement(tag, replyObj, options);\n        }\n      case 'topicRedirect':\n        {\n          return processTopicRedirect(tag, replyObj, options);\n        }\n      case 'respond':\n        {\n          return processRespond(tag, replyObj, options);\n        }\n      case 'customFunction':\n        {\n          return processCustomFunction(tag, replyObj, options);\n        }\n      case 'newTopic':\n        {\n          return processNewTopic(tag, replyObj, options);\n        }\n      case 'clearConversation':\n        {\n          return processClearConversation(tag, replyObj, options);\n        }\n      case 'continueSearching':\n        {\n          return processContinueSearching(tag, replyObj, options);\n        }\n      case 'endSearching':\n        {\n          return processEndSearching(tag, replyObj, options);\n        }\n      case 'redirect':\n        {\n          return processRedirect(tag, replyObj, options);\n        }\n      case 'alternates':\n        {\n          return processAlternates(tag, replyObj, options);\n        }\n      case 'delay':\n        {\n          return processDelay(tag, replyObj, options);\n        }\n      case 'setState':\n        {\n          return processSetState(tag, replyObj, options);\n        }\n      default:\n        {\n          throw new Error(`No such tag type: ${tagType}`);\n        }\n    }\n  });\n\n  function processTag(_x27, _x28, _x29) {\n    return _ref11.apply(this, arguments);\n  }\n\n  return processTag;\n})();\n\nconst processReplyTags = (() => {\n  var _ref12 = _asyncToGenerator(function* (replyObj, options) {\n    debug.verbose('Depth: ', options.depth);\n\n    let replyString = replyObj.reply.reply;\n    debug.info(`Reply before processing reply tags: \"${replyString}\"`);\n\n    options.topic = replyObj.topic;\n    replyObj.replyIds = [replyObj.reply._id];\n\n    // Deals with captures and wordnet lookups within functions as a preprocessing step\n    // e.g. ^myFunction(<cap1>, ~hey, \"otherThing\")\n    let preprocessed;\n    try {\n      preprocessed = yield preprocess(replyString, replyObj, options);\n    } catch (err) {\n      console.error(`There was an error preprocessing reply tags: ${err}`);\n      return null;\n    }\n\n    const replyTags = parser.parse(preprocessed);\n\n    let processedReplyParts;\n    try {\n      processedReplyParts = yield Promise.all(replyTags.map((() => {\n        var _ref13 = _asyncToGenerator(function* (tag) {\n          return processTag(tag, replyObj, options);\n        });\n\n        return function (_x32) {\n          return _ref13.apply(this, arguments);\n        };\n      })()));\n    } catch (err) {\n      console.error(`There was an error processing reply tags: ${err}`);\n      return null;\n    }\n\n    replyString = processedReplyParts.join('').trim();\n\n    const spaceRegex = /\\\\s/g;\n    replyObj.reply.reply = replyString.replace(spaceRegex, ' ');\n\n    debug.verbose('Final reply object from processTags: ', replyObj);\n\n    if (_lodash2.default.isEmpty(options.user.pendingTopic)) {\n      yield options.user.setTopic(replyObj.topic);\n    }\n\n    return replyObj;\n  });\n\n  function processReplyTags(_x30, _x31) {\n    return _ref12.apply(this, arguments);\n  }\n\n  return processReplyTags;\n})();\n\nconst processThreadTags = function processThreadTags(string) {\n  const threads = [];\n  const strings = [];\n  string.split('\\n').forEach(line => {\n    const match = line.match(_regexes2.default.delay);\n    if (match) {\n      threads.push({ delay: match[1], string: line.replace(match[0], '').trim() });\n    } else {\n      strings.push(line);\n    }\n  });\n  return [strings.join('\\n'), threads];\n};\n\nexports.default = {\n  preprocess,\n  processThreadTags,\n  processReplyTags\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/reply/wordnet.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _wordpos = require('wordpos');\n\nvar _wordpos2 = _interopRequireDefault(_wordpos);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } // This is a shim for wordnet lookup.\n// http://wordnet.princeton.edu/wordnet/man/wninput.5WN.html\n\nconst wordpos = new _wordpos2.default();\n\n// Unhandled promises should throw top-level errors, not just silently fail\nprocess.on('unhandledRejection', err => {\n  throw err;\n});\n\nconst define = (() => {\n  var _ref = _asyncToGenerator(function* (word) {\n    const results = yield wordpos.lookup(word);\n    if (_lodash2.default.isEmpty(results)) {\n      throw new Error(`No results for wordnet definition of '${word}'`);\n    }\n\n    return results[0].def;\n  });\n\n  function define(_x) {\n    return _ref.apply(this, arguments);\n  }\n\n  return define;\n})();\n\n// Does a word lookup\n// @word can be a word or a word/pos to filter out unwanted types\nconst lookup = (() => {\n  var _ref2 = _asyncToGenerator(function* (word, pointerSymbol = '~') {\n    let pos = null;\n\n    const match = word.match(/~(\\w)$/);\n    if (match) {\n      pos = match[1];\n      word = word.replace(match[0], '');\n    }\n\n    const synets = [];\n\n    const results = yield wordpos.lookup(word);\n    results.forEach(function (result) {\n      result.ptrs.forEach(function (part) {\n        if (pos !== null && part.pos === pos && part.pointerSymbol === pointerSymbol) {\n          synets.push(part);\n        } else if (pos === null && part.pointerSymbol === pointerSymbol) {\n          synets.push(part);\n        }\n      });\n    });\n\n    let items = yield Promise.all(synets.map((() => {\n      var _ref3 = _asyncToGenerator(function* (word) {\n        const sub = yield wordpos.seek(word.synsetOffset, word.pos);\n        return sub.lemma;\n      });\n\n      return function (_x3) {\n        return _ref3.apply(this, arguments);\n      };\n    })()));\n\n    items = _lodash2.default.uniq(items);\n    items = items.map(function (x) {\n      return x.replace(/_/g, ' ');\n    });\n    return items;\n  });\n\n  function lookup(_x2) {\n    return _ref2.apply(this, arguments);\n  }\n\n  return lookup;\n})();\n\n// Used to explore a word or concept\n// Spits out lots of info on the word\nconst explore = (() => {\n  var _ref4 = _asyncToGenerator(function* (word, cb) {\n    let ptrs = [];\n\n    const results = yield wordpos.lookup(word);\n    for (let i = 0; i < results.length; i++) {\n      ptrs.push(results[i].ptrs);\n    }\n\n    ptrs = _lodash2.default.uniq(_lodash2.default.flatten(ptrs));\n    ptrs = _lodash2.default.map(ptrs, function (item) {\n      return { pos: item.pos, sym: item.pointerSymbol };\n    });\n\n    ptrs = _lodash2.default.chain(ptrs).groupBy('pos').map(function (value, key) {\n      return {\n        pos: key,\n        ptr: _lodash2.default.uniq(_lodash2.default.map(value, 'sym'))\n      };\n    }).value();\n\n    return Promise.all(ptrs.map((() => {\n      var _ref5 = _asyncToGenerator(function* (item) {\n        return Promise.all(item.ptr.map((() => {\n          var _ref6 = _asyncToGenerator(function* (ptr) {\n            const res = yield lookup(`${word}~${item.pos}`, ptr);\n            console.log(word, item.pos, ':', ptr, res.join(', '));\n          });\n\n          return function (_x7) {\n            return _ref6.apply(this, arguments);\n          };\n        })()));\n      });\n\n      return function (_x6) {\n        return _ref5.apply(this, arguments);\n      };\n    })()));\n  });\n\n  function explore(_x4, _x5) {\n    return _ref4.apply(this, arguments);\n  }\n\n  return explore;\n})();\n\nexports.default = {\n  define,\n  explore,\n  lookup\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/reply/inlineRedirect.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nvar _ssMessage = require('ss-message');\n\nvar _ssMessage2 = _interopRequireDefault(_ssMessage);\n\nvar _common = require('./common');\n\nvar _common2 = _interopRequireDefault(_common);\n\nvar _getReply = require('../getReply');\n\nvar _getReply2 = _interopRequireDefault(_getReply);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst debug = (0, _debugLevels2.default)('SS:Reply:inline');\n\nconst inlineRedirect = (() => {\n  var _ref = _asyncToGenerator(function* (triggerTarget, options) {\n    debug.verbose(`Inline redirection to: '${triggerTarget}'`);\n\n    // if we have a special topic, reset it to the previous one\n    // in order to preserve the context for inline redirection\n    if (options.topic === '__pre__' || options.topic === '__post__') {\n      if (options.user.history.length !== 0) {\n        options.topic = options.user.history[0].topic;\n      }\n    }\n\n    let topicData;\n    try {\n      topicData = yield _common2.default.getTopic(options.system.chatSystem, options.topic);\n    } catch (err) {\n      console.error(err);\n      return {};\n    }\n\n    const messageOptions = {\n      factSystem: options.system.factSystem\n    };\n\n    const redirectMessage = yield new Promise(function (resolve, reject) {\n      _ssMessage2.default.createMessage(triggerTarget, messageOptions, function (err, redirectMessage) {\n        err ? reject(err) : resolve(redirectMessage);\n      });\n    });\n\n    options.pendingTopics = [topicData];\n\n    const redirectReply = yield new Promise(function (resolve, reject) {\n      (0, _getReply2.default)(redirectMessage, options, function (err, redirectReply) {\n        err ? reject(err) : resolve(redirectReply);\n      });\n    });\n\n    debug.verbose('Response from inlineRedirect: ', redirectReply);\n    return redirectReply || {};\n  });\n\n  function inlineRedirect(_x, _x2) {\n    return _ref.apply(this, arguments);\n  }\n\n  return inlineRedirect;\n})();\n\nexports.default = inlineRedirect;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/reply/topicRedirect.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nvar _ssMessage = require('ss-message');\n\nvar _ssMessage2 = _interopRequireDefault(_ssMessage);\n\nvar _common = require('./common');\n\nvar _common2 = _interopRequireDefault(_common);\n\nvar _getReply = require('../getReply');\n\nvar _getReply2 = _interopRequireDefault(_getReply);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst debug = (0, _debugLevels2.default)('SS:Reply:topicRedirect');\n\nconst topicRedirect = (() => {\n  var _ref = _asyncToGenerator(function* (topicName, topicTrigger, options) {\n    debug.verbose(`Topic redirection to topic: ${topicName}, trigger: ${topicTrigger}`);\n\n    // Here we are looking for gambits in the NEW topic.\n    // TODO: Deprecate this behaviour: a failed topic lookup should fail the whole reply\n    let topicData;\n    try {\n      topicData = yield _common2.default.getTopic(options.system.chatSystem, topicName);\n    } catch (err) {\n      console.error(err);\n      return {};\n    }\n\n    const messageOptions = {\n      factSystem: options.system.factSystem\n    };\n\n    const redirectMessage = yield new Promise(function (resolve, reject) {\n      _ssMessage2.default.createMessage(topicTrigger, messageOptions, function (err, redirectMessage) {\n        err ? reject(err) : resolve(redirectMessage);\n      });\n    });\n\n    options.pendingTopics = [topicData];\n\n    const redirectReply = yield new Promise(function (resolve, reject) {\n      (0, _getReply2.default)(redirectMessage, options, function (err, redirectReply) {\n        err ? reject(err) : resolve(redirectReply);\n      });\n    });\n\n    debug.verbose('redirectReply', redirectReply);\n    return redirectReply || {};\n  });\n\n  function topicRedirect(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  }\n\n  return topicRedirect;\n})();\n\nexports.default = topicRedirect;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/reply/respond.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nvar _common = require('./common');\n\nvar _common2 = _interopRequireDefault(_common);\n\nvar _getReply = require('../getReply');\n\nvar _getReply2 = _interopRequireDefault(_getReply);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst debug = (0, _debugLevels2.default)('SS:Reply:Respond');\n\nconst respond = (() => {\n  var _ref = _asyncToGenerator(function* (topicName, options) {\n    debug.verbose(`Responding to topic: ${topicName}`);\n\n    const topicData = yield _common2.default.getTopic(options.system.chatSystem, topicName);\n\n    options.pendingTopics = [topicData];\n\n    const respondReply = yield new Promise(function (resolve, reject) {\n      (0, _getReply2.default)(options.message, options, function (err, respondReply) {\n        err ? reject(err) : resolve(respondReply);\n      });\n    });\n\n    debug.verbose('Callback from respond getReply: ', respondReply);\n\n    return respondReply || {};\n  });\n\n  function respond(_x, _x2) {\n    return _ref.apply(this, arguments);\n  }\n\n  return respond;\n})();\n\nexports.default = respond;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/reply/customFunction.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst debug = (0, _debugLevels2.default)('SS:Reply:customFunction');\n\nconst customFunction = (() => {\n  var _ref = _asyncToGenerator(function* (functionName, functionArgs, replyObj, options) {\n    const plugins = options.system.plugins;\n    // Important to create a new scope object otherwise we could leak data\n    const scope = _lodash2.default.merge({}, options.system.scope);\n    scope.extraScope = options.system.extraScope;\n    scope.message = options.message;\n    scope.user = options.user;\n\n    if (!plugins[functionName]) {\n      // If a function is missing, we kill the line and return empty handed\n      throw new Error(`WARNING: Custom function (${functionName}) was not found. Your script may not behave as expected.`);\n    }\n\n    return new Promise(function (resolve, reject) {\n      functionArgs.push(function (err, functionResponse, stopMatching) {\n        let reply = '';\n        const props = {};\n        if (err) {\n          console.error(`Error in plugin function (${functionName}): ${err}`);\n          return reject(err);\n        }\n\n        if (_lodash2.default.isPlainObject(functionResponse)) {\n          if (functionResponse.text) {\n            reply = functionResponse.text;\n            delete functionResponse.text;\n          }\n\n          if (functionResponse.reply) {\n            reply = functionResponse.reply;\n            delete functionResponse.reply;\n          }\n\n          // There may be data, so merge it with the reply object\n          replyObj.props = _lodash2.default.merge(replyObj.props, functionResponse);\n          if (stopMatching !== undefined) {\n            replyObj.continueMatching = !stopMatching;\n          }\n        } else {\n          reply = functionResponse || '';\n          if (stopMatching !== undefined) {\n            replyObj.continueMatching = !stopMatching;\n          }\n        }\n\n        return resolve(reply);\n      });\n\n      debug.verbose(`Calling plugin function: ${functionName}`);\n      plugins[functionName].apply(scope, functionArgs);\n    });\n  });\n\n  function customFunction(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  }\n\n  return customFunction;\n})();\n\nexports.default = customFunction;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/getReply/getPendingTopics.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findPendingTopicsForUser = undefined;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nvar _natural = require('natural');\n\nvar _natural2 = _interopRequireDefault(_natural);\n\nvar _helpers = require('./helpers');\n\nvar _helpers2 = _interopRequireDefault(_helpers);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst debug = (0, _debugLevels2.default)('SS:Topics');\n\nconst TfIdf = _natural2.default.TfIdf;\n\n_natural2.default.PorterStemmer.attach();\n\n// Function to score the topics by TF-IDF\nconst scoreTopics = function scoreTopics(message, tfidf) {\n  let topics = [];\n  const tasMessage = message.lemString.tokenizeAndStem();\n  debug.verbose('Tokenised and stemmed words: ', tasMessage);\n\n  // Score the input against the topic keywords to come up with a topic order.\n  tfidf.tfidfs(tasMessage, (index, score, name) => {\n    // Filter out system topic pre/post\n    if (name !== '__pre__' && name !== '__post__') {\n      topics.push({ name, score, type: 'TOPIC' });\n    }\n  });\n\n  // Removes duplicate entries.\n  topics = _lodash2.default.uniqBy(topics, 'name');\n\n  const topicOrder = _lodash2.default.sortBy(topics, 'score').reverse();\n  debug.verbose('Scored topics: ', topicOrder);\n\n  return topicOrder;\n};\n\nconst removeMissingTopics = function removeMissingTopics(topics) {\n  return _lodash2.default.filter(topics, topic => topic.id);\n};\n\nconst findConversationTopics = (() => {\n  var _ref = _asyncToGenerator(function* (pendingTopics, user, chatSystem, conversationTimeout) {\n    if (user.history.length === 0) {\n      return pendingTopics;\n    }\n\n    // If we are currently in a conversation, we want the entire chain added\n    // to the topics to search\n    const lastReply = user.history[0].reply;\n    if (!_lodash2.default.isEmpty(lastReply)) {\n      // If the message is less than _ minutes old we continue\n      const delta = Date.now() - lastReply.createdAt;\n      if (delta <= conversationTimeout) {\n        debug.verbose(`Last reply string: ${lastReply.original}`);\n        debug.verbose(`Last reply sequence: ${lastReply.replyIds}`);\n        debug.verbose(`Clear conversation: ${lastReply.clearConversation}`);\n\n        if (lastReply.clearConversation) {\n          debug.verbose('Conversation RESET since clearConversation was true');\n          return pendingTopics;\n        }\n\n        const replies = yield chatSystem.Reply.find({ _id: { $in: lastReply.replyIds } }).lean().exec();\n        if (replies === []) {\n          debug.verbose(\"We couldn't match the last reply. Continuing.\");\n          return pendingTopics;\n        }\n\n        let replyThreads = [];\n\n        yield Promise.all(replies.map((() => {\n          var _ref2 = _asyncToGenerator(function* (reply) {\n            const threads = yield _helpers2.default.walkReplyParent(reply._id, chatSystem);\n            debug.verbose(`Threads found by walkReplyParent: ${threads}`);\n            threads.forEach(function (thread) {\n              return replyThreads.push(thread);\n            });\n          });\n\n          return function (_x5) {\n            return _ref2.apply(this, arguments);\n          };\n        })()));\n\n        replyThreads = replyThreads.map(function (item) {\n          return { id: item, type: 'REPLY' };\n        });\n        // This inserts the array replyThreads into pendingTopics after the first topic\n        pendingTopics.splice(1, 0, ...replyThreads);\n        return pendingTopics;\n      }\n\n      debug.info('The conversation thread was to old to continue it.');\n      return pendingTopics;\n    }\n  });\n\n  function findConversationTopics(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  }\n\n  return findConversationTopics;\n})();\n\nconst findPendingTopicsForUser = exports.findPendingTopicsForUser = (() => {\n  var _ref3 = _asyncToGenerator(function* (user, message, chatSystem, conversationTimeout) {\n    const allTopics = yield chatSystem.Topic.find({}).lean().exec();\n\n    const tfidf = new TfIdf();\n\n    allTopics.forEach(function (topic) {\n      const keywords = topic.keywords.join(' ');\n      if (keywords) {\n        tfidf.addDocument(keywords.tokenizeAndStem(), topic.name);\n      }\n    });\n\n    const scoredTopics = scoreTopics(message, tfidf);\n\n    const currentTopic = user.getTopic();\n\n    // Add the current topic to the front of the array.\n    scoredTopics.unshift({ name: currentTopic, type: 'TOPIC' });\n\n    let otherTopics = _lodash2.default.map(allTopics, function (topic) {\n      return { id: topic._id, name: topic.name, system: topic.system };\n    });\n\n    // This gets a list if all the remaining topics.\n    otherTopics = _lodash2.default.filter(otherTopics, function (topic) {\n      return !_lodash2.default.find(scoredTopics, { name: topic.name });\n    });\n\n    // We remove the system topics\n    otherTopics = _lodash2.default.filter(otherTopics, function (topic) {\n      return topic.system === false;\n    });\n\n    const pendingTopics = [];\n    pendingTopics.push({ name: '__pre__', type: 'TOPIC' });\n\n    for (let i = 0; i < scoredTopics.length; i++) {\n      if (scoredTopics[i].name !== '__pre__' && scoredTopics[i].name !== '__post__') {\n        pendingTopics.push(scoredTopics[i]);\n      }\n    }\n\n    // Search random as the highest priority after current topic and pre\n    if (!_lodash2.default.find(pendingTopics, { name: 'random' }) && _lodash2.default.find(otherTopics, { name: 'random' })) {\n      pendingTopics.push({ name: 'random', type: 'TOPIC' });\n    }\n\n    for (let i = 0; i < otherTopics.length; i++) {\n      if (otherTopics[i].name !== '__pre__' && otherTopics[i].name !== '__post__') {\n        otherTopics[i].type = 'TOPIC';\n        pendingTopics.push(otherTopics[i]);\n      }\n    }\n\n    pendingTopics.push({ name: '__post__', type: 'TOPIC' });\n\n    debug.verbose(`Pending topics before conversations: ${JSON.stringify(pendingTopics, null, 2)}`);\n\n    // Lets assign the ids to the topics\n    for (let i = 0; i < pendingTopics.length; i++) {\n      const topicName = pendingTopics[i].name;\n      for (let n = 0; n < allTopics.length; n++) {\n        if (allTopics[n].name === topicName) {\n          pendingTopics[i].id = allTopics[n]._id;\n        }\n      }\n    }\n\n    const allFoundTopics = yield findConversationTopics(pendingTopics, user, chatSystem, conversationTimeout);\n    return removeMissingTopics(allFoundTopics);\n  });\n\n  function findPendingTopicsForUser(_x6, _x7, _x8, _x9) {\n    return _ref3.apply(this, arguments);\n  }\n\n  return findPendingTopicsForUser;\n})();\n\nconst getPendingTopics = (() => {\n  var _ref4 = _asyncToGenerator(function* (messageObject, options) {\n    // We already have a pre-set list of potential topics from directReply, respond or topicRedirect\n    if (!_lodash2.default.isEmpty(_lodash2.default.reject(options.pendingTopics, _lodash2.default.isNull))) {\n      debug.verbose('Using pre-set topic list via directReply, respond or topicRedirect');\n      debug.info('Topics to check: ', options.pendingTopics.map(function (topic) {\n        return topic.name;\n      }));\n      return options.pendingTopics;\n    }\n\n    // Find potential topics for the response based on the message (tfidfs)\n    return findPendingTopicsForUser(options.user, messageObject, options.system.chatSystem, options.system.conversationTimeout);\n  });\n\n  function getPendingTopics(_x10, _x11) {\n    return _ref4.apply(this, arguments);\n  }\n\n  return getPendingTopics;\n})();\n\nexports.default = getPendingTopics;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/getReply/helpers.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.doesMatchTopic = exports.doesMatch = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nvar _safeEval = require('safe-eval');\n\nvar _safeEval2 = _interopRequireDefault(_safeEval);\n\nvar _postParse = require('../postParse');\n\nvar _postParse2 = _interopRequireDefault(_postParse);\n\nvar _utils = require('../utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst debug = (0, _debugLevels2.default)('SS:Helpers');\n\n// This will find all the gambits to process by parent (topic or conversation)\n// and return ones that match the message\nconst findMatchingGambitsForMessage = (() => {\n  var _ref = _asyncToGenerator(function* (type, parent, message, options) {\n    const matches = yield Promise.all(parent.gambits.map((() => {\n      var _ref2 = _asyncToGenerator(function* (gambit) {\n        const match = yield eachGambitHandle(gambit, message, options);\n        return match;\n      });\n\n      return function (_x5) {\n        return _ref2.apply(this, arguments);\n      };\n    })()));\n\n    return _lodash2.default.flatten(matches);\n  });\n\n  function findMatchingGambitsForMessage(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  }\n\n  return findMatchingGambitsForMessage;\n})();\n\nconst processStars = function processStars(match, gambit, topic) {\n  debug.verbose(`Match found: ${gambit.input} in topic: ${topic}`);\n  const stars = [];\n  if (match.length > 1) {\n    for (let j = 1; j < match.length; j++) {\n      if (match[j]) {\n        let starData = _utils2.default.trim(match[j]);\n        // Concepts are not allowed to be stars or captured input.\n        starData = starData[0] === '~' ? starData.substr(1) : starData;\n        stars.push(starData);\n      }\n    }\n  }\n\n  const data = { stars, gambit };\n  if (topic !== 'reply') {\n    data.topic = topic;\n  }\n\n  const matches = [data];\n  return matches;\n};\n\n/* This is a function to determine whether a certain key has been set to a certain value.\n * The double percentage sign (%%) syntax is used in the script to denote that a gambit\n * must meet a condition before being executed, e.g.\n *\n * %% (userKilledAlice === true)\n * + I love you.\n * - I still haven't forgiven you, you know.\n *\n * The context is whatever a user has previously set in any replies. So in this example,\n * if a user has set {userKilledAlice = true}, then the gambit is matched.\n */\nconst processConditions = function processConditions(conditions, options) {\n  const context = options.user.conversationState || {};\n\n  return _lodash2.default.every(conditions, condition => {\n    debug.verbose('Check condition - Context: ', context);\n    debug.verbose('Check condition - Condition: ', condition);\n\n    try {\n      const result = (0, _safeEval2.default)(condition, context);\n      if (result) {\n        debug.verbose('--- Condition TRUE ---');\n        return true;\n      }\n      debug.verbose('--- Condition FALSE ---');\n      return false;\n    } catch (e) {\n      debug.verbose(`Error in condition checking: ${e.stack}`);\n      return false;\n    }\n  });\n};\n\n/**\n * Takes a gambit and a message, and returns non-null if they match.\n */\nconst doesMatch = exports.doesMatch = (() => {\n  var _ref3 = _asyncToGenerator(function* (gambit, message, options) {\n    if (gambit.conditions && gambit.conditions.length > 0) {\n      const conditionsMatch = processConditions(gambit.conditions, options);\n      if (!conditionsMatch) {\n        debug.verbose('Conditions did not match');\n        return false;\n      }\n    }\n\n    let match = false;\n\n    // Replace <noun1>, <adverb1> etc. with the actual words in user message\n    const regexp = (0, _postParse2.default)(gambit.trigger, message, options.user);\n\n    const pattern = new RegExp(`^${regexp}$`, 'i');\n\n    debug.verbose(`Try to match (clean)'${message.clean}' against '${gambit.trigger}' (${pattern})`);\n    debug.verbose(`Try to match (lemma)'${message.lemString}' against '${gambit.trigger}' (${pattern})`);\n\n    // Match on isQuestion\n    if (gambit.isQuestion && message.isQuestion) {\n      debug.verbose('Gambit and message are questions, testing against question types');\n      match = message.clean.match(pattern);\n      if (!match) {\n        match = message.lemString.match(pattern);\n      }\n    } else if (!gambit.isQuestion) {\n      match = message.clean.match(pattern);\n      if (!match) {\n        match = message.lemString.match(pattern);\n      }\n    }\n\n    debug.verbose(`Match at the end of doesMatch was: ${match}`);\n\n    return match;\n  });\n\n  function doesMatch(_x6, _x7, _x8) {\n    return _ref3.apply(this, arguments);\n  }\n\n  return doesMatch;\n})();\n\n// TODO: This only exists for testing, ideally we should get rid of this\nconst doesMatchTopic = exports.doesMatchTopic = (() => {\n  var _ref4 = _asyncToGenerator(function* (topicName, message, options) {\n    const topic = yield options.chatSystem.Topic.findOne({ name: topicName }, 'gambits').populate('gambits').lean().exec();\n\n    return Promise.all(topic.gambits.map((() => {\n      var _ref5 = _asyncToGenerator(function* (gambit) {\n        return doesMatch(gambit, message, options);\n      });\n\n      return function (_x12) {\n        return _ref5.apply(this, arguments);\n      };\n    })()));\n  });\n\n  function doesMatchTopic(_x9, _x10, _x11) {\n    return _ref4.apply(this, arguments);\n  }\n\n  return doesMatchTopic;\n})();\n\n// This is the main function that looks for a matching entry\n// This takes a gambit that is a child of a topic or reply and checks if\n// it matches the user's message or not.\nconst eachGambitHandle = (() => {\n  var _ref6 = _asyncToGenerator(function* (gambit, message, options) {\n    const plugins = options.system.plugins;\n    const scope = options.system.scope;\n    const topic = options.topic || 'reply';\n    const chatSystem = options.system.chatSystem;\n\n    const match = yield doesMatch(gambit, message, options);\n    if (!match) {\n      return [];\n    }\n\n    // A filter is syntax that calls a plugin function such as:\n    // - {^functionX(true)} Yes, you are.\n    if (gambit.filter) {\n      debug.verbose(`We have a filter function: ${gambit.filter}`);\n\n      // The filterScope is what 'this' is during the execution of the plugin.\n      // This is so you can write plugins that can access, e.g. this.user or this.chatSystem\n      // Here we augment the global scope (system.scope) with any additional local scope for\n      // the current reply.\n      const filterScope = _lodash2.default.merge({}, scope);\n      filterScope.message = message;\n      // filterScope.message_props = options.localOptions.messageScope;\n      filterScope.user = options.user;\n\n      let filterReply;\n      try {\n        var _ref7 = yield _utils2.default.runPluginFunc(gambit.filter, filterScope, plugins);\n\n        var _ref8 = _slicedToArray(_ref7, 1);\n\n        filterReply = _ref8[0];\n      } catch (err) {\n        console.error(err);\n        return [];\n      }\n\n      debug.verbose(`Reply from filter function was: ${filterReply}`);\n\n      if (filterReply !== 'true' && filterReply !== true) {\n        debug.verbose('Gambit is not matched since the filter function returned false');\n        return [];\n      }\n    }\n\n    if (gambit.redirect !== '') {\n      debug.verbose('Gambit has a redirect', topic);\n      // FIXME: ensure this works\n      const redirectedGambit = yield chatSystem.Gambit.findOne({ input: gambit.redirect }).populate({ path: 'replies' }).lean().exec();\n      return processStars(match, redirectedGambit, topic);\n    }\n\n    // Tag the message with the found Trigger we matched on\n    message.gambitId = gambit._id;\n    return processStars(match, gambit, topic);\n  });\n\n  function eachGambitHandle(_x13, _x14, _x15) {\n    return _ref6.apply(this, arguments);\n  }\n\n  return eachGambitHandle;\n})();\n\nconst walkGambitParent = (() => {\n  var _ref9 = _asyncToGenerator(function* (gambitId, chatSystem) {\n    const gambitIds = [];\n    try {\n      const gambit = yield chatSystem.Gambit.findById(gambitId, '_id parent').populate('parent').lean().exec();\n      debug.verbose('Walk', gambit);\n\n      if (gambit) {\n        gambitIds.push(gambit._id);\n        if (gambit.parent && gambit.parent.parent) {\n          const parents = yield walkGambitParent(gambit.parent.parent, chatSystem);\n          return gambitIds.concat(parents);\n        }\n      }\n    } catch (err) {\n      console.error(err);\n    }\n    return gambitIds;\n  });\n\n  function walkGambitParent(_x16, _x17) {\n    return _ref9.apply(this, arguments);\n  }\n\n  return walkGambitParent;\n})();\n\nconst walkReplyParent = (() => {\n  var _ref10 = _asyncToGenerator(function* (replyId, chatSystem) {\n    const replyIds = [];\n    try {\n      const reply = yield chatSystem.Reply.findById(replyId, '_id parent').populate('parent').lean().exec();\n      debug.verbose('Walk', reply);\n\n      if (reply) {\n        replyIds.push(reply._id);\n        if (reply.parent && reply.parent.parent) {\n          const parents = yield walkReplyParent(reply.parent.parent, chatSystem);\n          return replyIds.concat(parents);\n        }\n      }\n    } catch (err) {\n      console.error(err);\n    }\n    return replyIds;\n  });\n\n  function walkReplyParent(_x18, _x19) {\n    return _ref10.apply(this, arguments);\n  }\n\n  return walkReplyParent;\n})();\n\nconst getRootTopic = (() => {\n  var _ref11 = _asyncToGenerator(function* (gambit, chatSystem) {\n    if (!gambit.parent) {\n      return chatSystem.Topic.findOne({ gambits: { $in: [gambit._id] } }).lean().exec();\n    }\n\n    const gambits = yield walkGambitParent(gambit._id, chatSystem);\n    if (gambits.length !== 0) {\n      return chatSystem.Topic.findOne({ gambits: { $in: [gambits.pop()] } }).lean().exec();\n    }\n\n    return chatSystem.Topic.findOne({ name: 'random' }).lean().exec();\n  });\n\n  function getRootTopic(_x20, _x21) {\n    return _ref11.apply(this, arguments);\n  }\n\n  return getRootTopic;\n})();\n\nexports.default = {\n  findMatchingGambitsForMessage,\n  getRootTopic,\n  walkReplyParent\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/postParse.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst searchRE = /<(name|noun|adverb|verb|pronoun|adjective)(s|[0-9]+)?>/g;\nconst inputReplyRE = /<(input|reply)([1-9])?>/g;\n\n/**\n * This function replaces syntax in the trigger such as:\n * <noun1> <adverb2> <pronoun2>\n * with the respective word in the user's message.\n *\n * - `<basename>` gets replaced by `(replacements[0])`\n * - `<basenames>` gets replaced by `(replacements[0]|replacements[1]|...)`\n * - `<basenameN>` gets replaced by `(replacements[N])`\n *\n * This function contains the user object so it may be contextual to this user.\n */\nconst postParse = function postParse(regexp, message, user) {\n  if (_lodash2.default.isNull(regexp)) {\n    return null;\n  }\n\n  regexp = regexp.replace(searchRE, (match, p1, p2) => {\n    let replacements = null;\n\n    switch (p1) {\n      case 'name':\n        replacements = message.names;break;\n      case 'noun':\n        replacements = message.nouns;break;\n      case 'adverb':\n        replacements = message.adverbs;break;\n      case 'verb':\n        replacements = message.verbs;break;\n      case 'pronoun':\n        replacements = message.pronouns;break;\n      case 'adjective':\n        replacements = message.adjectives;break;\n      default:\n        break;\n    }\n\n    if (replacements.length > 0) {\n      if (p2 === 's') {\n        return `(${replacements.join('|')})`;\n      }\n\n      let index = Number.parseInt(p2);\n      index = index ? index - 1 : 0;\n      if (index < replacements.length) {\n        return `(${replacements[index]})`;\n      }\n    }\n\n    return '';\n  });\n\n  if (user && user.history) {\n    const history = user.history;\n    regexp = regexp.replace(inputReplyRE, (match, p1, p2) => {\n      const index = p2 ? Number.parseInt(p2) : 0;\n      return history[index][p1] ? history[index][p1].original : match;\n    });\n  }\n\n  return regexp;\n};\n\nexports.default = postParse;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/getReply/filterFunction.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nvar _processTags = require('../processTags');\n\nvar _processTags2 = _interopRequireDefault(_processTags);\n\nvar _utils = require('../utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst debug = (0, _debugLevels2.default)('SS:FilterFunction');\n\nconst filterRepliesByFunction = (() => {\n  var _ref = _asyncToGenerator(function* (potentialReplies, options) {\n    const bits = yield Promise.all(potentialReplies.map((() => {\n      var _ref2 = _asyncToGenerator(function* (potentialReply) {\n        const system = options.system;\n\n        // We support a single filter function in the reply\n        // It returns true/false to aid in the selection.\n\n        if (potentialReply.reply.filter) {\n          const stars = { stars: potentialReply.stars };\n          const cleanFilter = yield _processTags2.default.preprocess(potentialReply.reply.filter, stars, options);\n\n          debug.verbose(`Reply filter function found: ${cleanFilter}`);\n\n          const filterScope = _lodash2.default.merge({}, system.scope);\n          filterScope.user = options.user;\n          filterScope.message = options.message;\n          filterScope.message_props = options.system.extraScope;\n\n          try {\n            var _ref3 = yield _utils2.default.runPluginFunc(cleanFilter, filterScope, system.plugins),\n                _ref4 = _slicedToArray(_ref3, 1);\n\n            const filterReply = _ref4[0];\n\n            if (filterReply === 'true' || filterReply === true) {\n              return true;\n            }\n            return false;\n          } catch (err) {\n            console.error(err);\n            return false;\n          }\n        }\n\n        return true;\n      });\n\n      return function (_x3) {\n        return _ref2.apply(this, arguments);\n      };\n    })()));\n\n    potentialReplies = potentialReplies.filter(function () {\n      return bits.shift();\n    });\n\n    return potentialReplies;\n  });\n\n  function filterRepliesByFunction(_x, _x2) {\n    return _ref.apply(this, arguments);\n  }\n\n  return filterRepliesByFunction;\n})();\n\nexports.default = filterRepliesByFunction;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/getReply/filterSeen.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst debug = (0, _debugLevels2.default)('SS:FilterSeen');\n\n// This may be called several times, once for each topic.\nconst filterRepliesBySeen = (() => {\n  var _ref = _asyncToGenerator(function* (filteredResults, options) {\n    debug.verbose('filterRepliesBySeen', filteredResults);\n\n    const bucket = filteredResults.map(function (filteredResult) {\n      const replyId = filteredResult.reply._id;\n      if (!filteredResult.seenCount) {\n        filteredResult.seenCount = 0;\n      }\n      options.user.history.map(function (historyItem) {\n        if (historyItem.topic !== undefined) {\n          const pastGambit = historyItem.reply;\n          const pastInput = historyItem.input;\n\n          if (pastGambit && pastInput) {\n            if (pastGambit.replyIds && pastGambit.replyIds.find(function (id) {\n              return String(id) === String(replyId);\n            })) {\n              debug.verbose('Already Seen', filteredResult.reply);\n              filteredResult.seenCount += 1;\n            }\n          }\n        }\n      });\n      return filteredResult;\n    });\n    return bucket;\n  });\n\n  function filterRepliesBySeen(_x, _x2) {\n    return _ref.apply(this, arguments);\n  }\n\n  return filterRepliesBySeen;\n})();\n\nexports.default = filterRepliesBySeen;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/getReply/processReplyTags.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nvar _processTags = require('../processTags');\n\nvar _processTags2 = _interopRequireDefault(_processTags);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst debug = (0, _debugLevels2.default)('SS:GetReply:ProcessTags');\n\nconst processReplyTags = (() => {\n  var _ref = _asyncToGenerator(function* (reply, options) {\n    let replyObj;\n    try {\n      replyObj = yield _processTags2.default.processReplyTags(reply, options);\n    } catch (err) {\n      debug.verbose('There was an error in processTags: ', err);\n    }\n\n    if (!_lodash2.default.isEmpty(replyObj)) {\n      // reply is the selected reply object that we created earlier (wrapped mongoDB reply)\n      // reply.reply is the actual mongoDB reply object\n      // reply.reply.reply is the reply string\n      replyObj.matched_reply_string = reply.reply.reply;\n      replyObj.matched_topic_string = reply.topic;\n\n      debug.verbose('Reply object after processing tags: ', replyObj);\n\n      return replyObj;\n    }\n\n    debug.verbose('No reply object was received from processTags so check for more.');\n    return null;\n  });\n\n  function processReplyTags(_x, _x2) {\n    return _ref.apply(this, arguments);\n  }\n\n  return processReplyTags;\n})();\n\nexports.default = processReplyTags;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/db/import.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _async = require('async');\n\nvar _async2 = _interopRequireDefault(_async);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _debugLevels = require('debug-levels');\n\nvar _debugLevels2 = _interopRequireDefault(_debugLevels);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n *  Import a data file into MongoDB\n */\n\nconst debug = (0, _debugLevels2.default)('SS:Importer');\n\n// Whenever and only when a breaking change is made to ss-parser, this needs\n// to be updated.\nconst MIN_SUPPORTED_SCRIPT_VERSION = 1;\n\nconst rawToGambitData = function rawToGambitData(gambitId, gambit) {\n  const gambitData = {\n    id: gambitId,\n    isQuestion: gambit.trigger.question,\n    conditions: gambit.conditional,\n    filter: gambit.trigger.filter,\n    trigger: gambit.trigger.clean,\n    input: gambit.trigger.raw\n  };\n\n  // Conditional rolled up triggers will not have a flags\n  if (gambit.trigger.flags && gambit.trigger.flags.order) {\n    gambitData.reply_order = gambit.trigger.flags.order;\n  }\n\n  if (gambit.trigger.flags && gambit.trigger.flags.keep) {\n    gambitData.reply_exhaustion = gambit.trigger.flags.keep;\n  }\n\n  if (gambit.redirect) {\n    gambitData.redirect = gambit.redirect;\n  }\n\n  return gambitData;\n};\n\nconst importData = function importData(chatSystem, data, callback) {\n  if (!data.version || data.version < MIN_SUPPORTED_SCRIPT_VERSION) {\n    return callback(`Error: Your script has version ${data.version} but the minimum supported version is ${MIN_SUPPORTED_SCRIPT_VERSION}.\\nPlease either re-parse your file with a supported parser version, or update SuperScript.`);\n  }\n\n  const Topic = chatSystem.Topic;\n  const Gambit = chatSystem.Gambit;\n  const Reply = chatSystem.Reply;\n  const User = chatSystem.User;\n\n  const gambitsWithConversation = [];\n\n  const eachReplyItor = function eachReplyItor(gambit) {\n    return (replyId, nextReply) => {\n      debug.verbose('Reply process: %s', replyId);\n      const properties = {\n        id: replyId,\n        reply: data.replies[replyId].string,\n        keep: data.replies[replyId].keep,\n        filter: data.replies[replyId].filter,\n        parent: gambit._id\n      };\n\n      gambit.addReply(properties, err => {\n        if (err) {\n          console.error(err);\n        }\n        nextReply();\n      });\n    };\n  };\n\n  const eachGambitItor = function eachGambitItor(topic) {\n    return (gambitId, nextGambit) => {\n      const gambit = data.gambits[gambitId];\n      if (gambit.conversation) {\n        debug.verbose('Gambit has conversation (deferring process): %s', gambitId);\n        gambitsWithConversation.push(gambitId);\n        nextGambit();\n      } else if (gambit.topic === topic.name) {\n        debug.verbose('Gambit process: %s', gambitId);\n        const gambitData = rawToGambitData(gambitId, gambit);\n\n        topic.createGambit(gambitData, (err, mongoGambit) => {\n          if (err) {\n            console.error(err);\n          }\n          _async2.default.eachSeries(gambit.replies, eachReplyItor(mongoGambit), err => {\n            if (err) {\n              console.error(err);\n            }\n            nextGambit();\n          });\n        });\n      } else {\n        nextGambit();\n      }\n    };\n  };\n\n  const eachTopicItor = function eachTopicItor(topicName, nextTopic) {\n    const topic = data.topics[topicName];\n    debug.verbose(`Find or create topic with name '${topicName}'`);\n    const topicProperties = {\n      name: topic.name,\n      keep: topic.flags.keep,\n      nostay: topic.flags.stay === false,\n      system: topic.flags.system,\n      keywords: topic.keywords,\n      filter: topic.filter,\n      reply_order: topic.flags.order || null,\n      reply_exhaustion: topic.flags.keep || null\n    };\n\n    debug.verbose('Creating Topic w/ Settings', topicProperties);\n    Topic.findOneAndUpdate({ name: topic.name }, topicProperties, {\n      upsert: true,\n      setDefaultsOnInsert: true,\n      new: true\n    }, (err, mongoTopic) => {\n      if (err) {\n        console.error(err);\n      }\n\n      _async2.default.eachSeries(Object.keys(data.gambits), eachGambitItor(mongoTopic), err => {\n        if (err) {\n          console.error(err);\n        }\n        debug.verbose(`All gambits for ${topic.name} processed.`);\n        nextTopic();\n      });\n    });\n  };\n\n  const eachConvItor = function eachConvItor(gambitId) {\n    return (replyId, nextConv) => {\n      debug.verbose('conversation/reply: %s', replyId);\n      Reply.findOne({ id: replyId }, (err, reply) => {\n        if (err) {\n          console.error(err);\n        }\n        if (reply) {\n          reply.gambits.addToSet(gambitId);\n          reply.save(err => {\n            if (err) {\n              console.error(err);\n            }\n            reply.sortGambits(() => {\n              debug.verbose('All conversations for %s processed.', gambitId);\n              nextConv();\n            });\n          });\n        } else {\n          debug.warn('No reply found!');\n          nextConv();\n        }\n      });\n    };\n  };\n\n  debug.info('Cleaning database: removing all data.');\n\n  // Remove everything before we start importing\n  _async2.default.each([Gambit, Reply, Topic, User], (model, nextModel) => {\n    model.remove({}, err => nextModel());\n  }, err => {\n    _async2.default.eachSeries(Object.keys(data.topics), eachTopicItor, () => {\n      _async2.default.eachSeries(_lodash2.default.uniq(gambitsWithConversation), (gambitId, nextGambit) => {\n        const gambitRawData = data.gambits[gambitId];\n\n        const conversations = gambitRawData.conversation || [];\n        if (conversations.length === 0) {\n          return nextGambit();\n        }\n\n        const gambitData = rawToGambitData(gambitId, gambitRawData);\n        // TODO: gambit.parent should be able to be multiple replies, not just conversations[0]\n        const replyId = conversations[0];\n\n        // TODO??: Add reply.addGambit(...)\n        Reply.findOne({ id: replyId }, (err, reply) => {\n          if (!reply) {\n            console.error(`Gambit ${gambitId} is supposed to have conversations (has %), but none were found.`);\n            nextGambit();\n          }\n          const gambit = new Gambit(gambitData);\n          _async2.default.eachSeries(gambitRawData.replies, eachReplyItor(gambit), err => {\n            debug.verbose('All replies processed.');\n            gambit.parent = reply._id;\n            debug.verbose('Saving new gambit: ', err, gambit);\n            gambit.save((err, gam) => {\n              if (err) {\n                console.log(err);\n              }\n              _async2.default.mapSeries(conversations, eachConvItor(gam._id), (err, results) => {\n                debug.verbose('All conversations for %s processed.', gambitId);\n                nextGambit();\n              });\n            });\n          });\n        });\n      }, () => {\n        callback(null, 'done');\n      });\n    });\n  });\n};\n\nconst importFile = function importFile(chatSystem, path, callback) {\n  _fs2.default.readFile(path, (err, jsonFile) => {\n    if (err) {\n      console.log(err);\n    }\n    return importData(chatSystem, JSON.parse(jsonFile), callback);\n  });\n};\n\nexports.default = { importFile, importData };","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bot/logger.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _mkdirp = require('mkdirp');\n\nvar _mkdirp2 = _interopRequireDefault(_mkdirp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Logger {\n  constructor(logPath) {\n    if (logPath) {\n      try {\n        _mkdirp2.default.sync(logPath);\n        this.logPath = logPath;\n      } catch (e) {\n        console.error(`Could not create logs folder at ${logPath}: ${e}`);\n      }\n    }\n  }\n\n  log(message, logName = 'default') {\n    if (this.logPath) {\n      const filePath = `${this.logPath}/${logName}.log`;\n      try {\n        _fs2.default.appendFileSync(filePath, message);\n      } catch (e) {\n        console.error(`Could not write log to file with path: ${filePath}`);\n      }\n    }\n  }\n}\n\nexports.default = Logger;","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/clients/express.js":"import superscript from 'superscript';\nimport express from 'express';\nimport bodyParser from 'body-parser';\n\nconst server = express();\nconst PORT = process.env.PORT || 5000;\n\nserver.use(bodyParser.json());\n\nlet bot;\n\nserver.get('/superscript', (req, res) => {\n  if (req.query.message) {\n    return bot.reply('user1', req.query.message, (err, reply) => {\n      res.json({\n        message: reply.string,\n      });\n    });\n  }\n  return res.json({ error: 'No message provided.' });\n});\n\nconst options = {\n  factSystem: {\n    clean: true,\n  },\n  importFile: './data.json',\n};\n\nsuperscript.setup(options, (err, botInstance) => {\n  if (err) {\n    console.error(err);\n  }\n  bot = botInstance;\n\n  server.listen(PORT, () => {\n    console.log(`===> 🚀  Server is now running on port ${PORT}`);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/clients/hangout.js":"import superscript from 'superscript';\nimport xmpp from 'simple-xmpp';\n\nconst receiveData = function receiveData(from, bot, data) {\n  // Handle incoming messages.\n  let message = `${data}`;\n\n  message = message.replace(/[\\x0D\\x0A]/g, '');\n\n  bot.reply(from, message.trim(), (err, reply) => {\n    xmpp.send(from, reply.string);\n  });\n};\n\n// You need authorize this authentication method in Google account.\nconst botHandle = function botHandle(err, bot) {\n  xmpp.connect({\n    jid: 'EMAIL ADRESS',\n    password: 'PASSWORD',\n    host: 'talk.google.com',\n    port: 5222,\n    reconnect: true,\n  });\n\n  xmpp.on('online', (data) => {\n    console.log(`Connected with JID: ${data.jid.user}`);\n    console.log('Yes, I\\'m connected!');\n  });\n\n  xmpp.on('chat', (from, message) => {\n    receiveData(from, bot, message);\n  });\n\n  xmpp.on('error', (err) => {\n    console.error(err);\n  });\n};\n\n// Main entry point\nconst options = {\n  factSystem: {\n    clean: true,\n  },\n  importFile: './data.json',\n};\n\nsuperscript.setup(options, (err, bot) => {\n  botHandle(null, bot);\n});\n","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/clients/slack.js":"import superscript from 'superscript';\n// slack-client provides auth and sugar around dealing with the RealTime API.\nimport Slack from 'slack-client';\n\n// Auth Token - You can generate your token from\n// https://<slack_name>.slack.com/services/new/bot\nconst token = '...';\n\n// How should we reply to the user?\n// direct - sents a DM\n// atReply - sents a channel message with @username\n// public sends a channel reply with no username\nconst replyType = 'atReply';\n\nconst atReplyRE = /<@(.*?)>/;\n\nconst slack = new Slack(token, true, true);\n\nconst receiveData = function receiveData(slack, bot, data) {\n  // Fetch the user who sent the message;\n  const user = data._client.users[data.user];\n  let channel;\n  const messageData = data.toJSON();\n  let message = '';\n\n  if (messageData && messageData.text) {\n    message = `${messageData.text.trim()}`;\n  }\n\n  const match = message.match(atReplyRE);\n\n  // Are they talking to us?\n  if (match && match[1] === slack.self.id) {\n    message = message.replace(atReplyRE, '').trim();\n    if (message[0] === ':') {\n      message = message.substring(1).trim();\n    }\n\n    bot.reply(user.name, message, (err, reply) => {\n      // We reply back direcly to the user\n      switch (replyType) {\n        case 'direct':\n          channel = slack.getChannelGroupOrDMByName(user.name);\n          break;\n        case 'atReply':\n          reply.string = `@${user.name} ${reply.string}`;\n          channel = slack.getChannelGroupOrDMByID(messageData.channel);\n          break;\n        case 'public':\n          channel = slack.getChannelGroupOrDMByID(messageData.channel);\n          break;\n      }\n\n      if (reply.string) {\n        channel.send(reply.string);\n      }\n    });\n  } else if (messageData.channel[0] === 'D') {\n    bot.reply(user.name, message, (err, reply) => {\n      channel = slack.getChannelGroupOrDMByName(user.name);\n      if (reply.string) {\n        channel.send(reply.string);\n      }\n    });\n  } else {\n    console.log('Ignoring...', messageData);\n  }\n};\n\nconst botHandle = function botHandle(err, bot) {\n  slack.login();\n\n  slack.on('error', (error) => {\n    console.error(`Error: ${error}`);\n  });\n\n  slack.on('open', () => {\n    console.log('Welcome to Slack. You are %s of %s', slack.self.name, slack.team.name);\n  });\n\n  slack.on('close', () => {\n    console.warn('Disconnected');\n  });\n\n  slack.on('message', (data) => {\n    receiveData(slack, bot, data);\n  });\n};\n\n// Main entry point\nconst options = {\n  factSystem: {\n    clean: true,\n  },\n  importFile: './data.json',\n};\n\nsuperscript.setup(options, (err, bot) => {\n  botHandle(null, bot);\n});\n","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/clients/telegram.js":"import TelegramBot from 'node-telegram-bot-api';\nimport superscript from 'superscript';\n\nconst options = {\n  factSystem: {\n    clean: true,\n  },\n  importFile: './data.json',\n};\n\nsuperscript.setup(options, (err, bot) => {\n  if (err) {\n    console.error(err);\n  }\n  // Auth Token - You can generate your token from @BotFather\n  // @BotFather is the one bot to rule them all.\n  const token = '...';\n\n  //= == Polling ===\n  const telegram = new TelegramBot(token, {\n    polling: true,\n  });\n\n  //= == Webhook ===\n  // Choose a port\n  // var port = 8080;\n\n  // var telegram = new TelegramBot(token, {\n  //    webHook: {\n  //        port: port,\n  //        host: 'localhost'\n  //    }\n  // });\n\n  // Use `ngrok http 8080` to tunnels localhost to a https endpoint. Get it at https://ngrok.com/\n  // telegram.setWebHook('https://_____.ngrok.io/' + token);\n\n  telegram.on('message', (msg) => {\n    const fromId = msg.from.id;\n    const text = msg.text.trim();\n\n    bot.reply(fromId, text, (err, reply) => {\n      if (reply.string) {\n        telegram.sendMessage(fromId, reply.string);\n        // From file\n        // var photo = __dirname+'/../test/bot.gif';\n        // telegram.sendPhoto(fromId, photo, {caption: \"I'm a bot!\"});\n\n        // For more examples, check out https://github.com/yagop/node-telegram-bot-api\n      }\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/clients/telnet.js":"// Run this and then telnet to localhost:2000 and chat with the bot\n\nimport net from 'net';\nimport superscript from 'superscript';\n\nconst sockets = [];\n\nconst botHandle = function botHandle(err, bot) {\n  const receiveData = function receiveData(socket, bot, data) {\n    // Handle incoming messages.\n    let message = `${data}`;\n\n    message = message.replace(/[\\x0D\\x0A]/g, '');\n\n    if (message.indexOf('/quit') === 0 || data.toString('hex', 0, data.length) === 'fff4fffd06') {\n      socket.end('Good-bye!\\n');\n      return;\n    }\n\n    // Use the remoteIP as the name since the PORT changes on ever new connection.\n    bot.reply(socket.remoteAddress, message.trim(), (err, reply) => {\n      // Find the right socket\n      const i = sockets.indexOf(socket);\n      const soc = sockets[i];\n\n      soc.write(`\\nBot> ${reply.string}\\n`);\n      soc.write('You> ');\n    });\n  };\n\n  const closeSocket = function closeSocket(socket, bot) {\n    const i = sockets.indexOf(socket);\n    const soc = sockets[i];\n\n    console.log(`User '${soc.name}' has disconnected.\\n`);\n\n    if (i !== -1) {\n      sockets.splice(i, 1);\n    }\n  };\n\n  const newSocket = function newSocket(socket) {\n    socket.name = `${socket.remoteAddress}:${socket.remotePort}`;\n    console.log(`User '${socket.name}' has connected.\\n`);\n\n    sockets.push(socket);\n\n    // Send a welcome message.\n    socket.write('Welcome to the Telnet server!\\n');\n    socket.write(`Hello ${socket.name}! ` + 'Type /quit to disconnect.\\n\\n');\n\n    // Send their prompt.\n    socket.write('You> ');\n\n    socket.on('data', (data) => {\n      receiveData(socket, bot, data);\n    });\n\n    // Handle disconnects.\n    socket.on('end', () => {\n      closeSocket(socket, bot);\n    });\n  };\n\n  // Start the TCP server.\n  const server = net.createServer(newSocket);\n\n  server.listen(2000);\n  console.log('TCP server running on port 2000.\\n');\n};\n\n// This assumes the topics have been compiled to data.json first\n// See superscript/src/bin/parse for information on how to do that.\n\n// Main entry point\nconst options = {\n  factSystem: {\n    clean: true,\n  },\n  importFile: './data.json',\n};\n\nsuperscript.setup(options, (err, bot) => {\n  botHandle(null, bot);\n});\n","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/clients/twilio.js":"import express from 'express';\nimport session from 'express-session';\nimport connectMongo from 'connect-mongo';\nimport bodyParser from 'body-parser';\nimport twilio from 'twilio';\nimport superscript from 'superscript';\n\nconst app = express();\nconst MongoStore = connectMongo(session);\n\n// Twilio Configuration\n// Number format should be \"+19876543210\", with \"+1\" the country code\nconst twilioConfig = {\n  account: '[YOUR_TWILIO_SID]',\n  token: '[YOUR_TWILIO_TOKEN]',\n  number: '[YOUR_TWILIO_NUMBER]',\n};\n\nconst accountSid = process.env.TWILIO_SID || twilioConfig.account;\nconst authToken = process.env.TWILIO_AUTH || twilioConfig.token;\nconst twilioNum = process.env.NUM || twilioConfig.number;\n\ntwilio.client = twilio(accountSid, authToken);\ntwilio.handler = twilio;\ntwilio.authToken = authToken;\ntwilio.num = twilioNum;\n\n// Send Twilio text message\nconst sendSMS = function sendSMS(recipient, sender, message) {\n  twilio.client.messages.create({\n    to: recipient,\n    from: sender,\n    body: message,\n  }, (err, result) => {\n    if (!err) {\n      console.log('Reply sent! The SID for this message is: ');\n      console.log(result.sid);\n      console.log('Message sent on');\n      console.log(result.dateCreated);\n    } else {\n      console.log('Error sending message');\n      console.log(err);\n    }\n  });\n};\n\nconst dataHandle = function dataHandle(data, phoneNumber, twilioNumber, bot) {\n    // Format message\n  let message = `${data}`;\n\n  message = message.replace(/[\\x0D\\x0A]/g, '');\n\n  bot.reply(message.trim(), (err, reply) => {\n    sendSMS(phoneNumber, twilioNumber, reply.string);\n  });\n};\n\n// TWILIO\n// In your Twilio account, set up Twilio Messaging \"Request URL\" as HTTP POST\n// If running locally and using ngrok, should look something like: http://b2053b5e.ngrok.io/api/messages\nconst botHandle = function (err, bot) {\n  app.post('/api/messages', (req, res) => {\n    if (twilio.handler.validateExpressRequest(req, twilio.authToken)) {\n      console.log(`Twilio Message Received: ${req.body.Body}`);\n      dataHandle(req.body.Body, req.body.From, twilio.num, bot);\n    } else {\n      res.set('Content-Type', 'text/xml').status(403).send('Error handling text messsage. Check your request params');\n    }\n  });\n};\n\n// Main entry point\nconst options = {\n  factSystem: {\n    clean: true,\n  },\n  importFile: './data.json',\n};\n\nsuperscript.setup(options, (err, bot) => {\n  // Middleware\n  app.use(bodyParser.json());\n  app.use(bodyParser.urlencoded({ extended: true }));\n  app.use(session({\n    secret: 'cellar door',\n    resave: true,\n    saveUninitialized: false,\n    store: new MongoStore({ mongooseConnection: bot.db }),\n  }));\n\n  // PORT\n  const port = process.env.PORT || 3000;\n\n  // START SERVER\n  app.listen(port, () => {\n    console.log(`Listening on port: ${port}`);\n  });\n\n  botHandle(null, bot);\n});\n","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bin/bot-init.js":"#!/usr/bin/env node\n'use strict';\n\nvar _commander = require('commander');\n\nvar _commander2 = _interopRequireDefault(_commander);\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_commander2.default.version('1.0.0').usage('botname [options]').option('-c, --clients [telnet]', 'Bot clients (express, hangout, slack, telegram, telnet, twilio) [default: telnet]', 'telnet').parse(process.argv);\n\nif (!_commander2.default.args[0]) {\n  _commander2.default.help();\n  process.exit(1);\n}\n\nconst botName = _commander2.default.args[0];\nconst botPath = _path2.default.join(process.cwd(), botName);\nconst ssRoot = _path2.default.join(__dirname, '..', '..');\n\nconst write = function write(path, str, mode = 0o666) {\n  _fs2.default.writeFileSync(path, str, { mode });\n  console.log(`   \\x1b[36mcreate\\x1b[0m : ${path}`);\n};\n\n// Creating the path for your bot.\n_fs2.default.mkdir(botPath, err => {\n  if (err && err.code === 'EEXIST') {\n    console.error(`\\n\\nThere is already a bot named ${botName} at ${botPath}.\\nPlease remove it or pick a new name for your bot before continuing.\\n`);\n    process.exit(1);\n  } else if (err) {\n    console.error(`We could not create the bot: ${err}`);\n    process.exit(1);\n  }\n\n  _fs2.default.mkdirSync(_path2.default.join(botPath, 'chat'));\n  _fs2.default.mkdirSync(_path2.default.join(botPath, 'plugins'));\n  _fs2.default.mkdirSync(_path2.default.join(botPath, 'src'));\n\n  // package.json\n  const pkg = {\n    name: botName,\n    version: '0.0.0',\n    private: true,\n    dependencies: {\n      superscript: '^1.0.0'\n    },\n    devDependencies: {\n      'babel-cli': '^6.16.0',\n      'babel-preset-es2015': '^6.16.0'\n    },\n    scripts: {\n      build: 'babel src --presets babel-preset-es2015 --out-dir lib'\n    }\n  };\n\n  const clients = _commander2.default.clients.split(',');\n\n  clients.forEach(client => {\n    const clientName = client.toLowerCase();\n\n    if (['express', 'hangout', 'slack', 'telegram', 'telnet', 'twilio'].indexOf(clientName) === -1) {\n      console.log(`Cannot create bot with client type: ${clientName}`);\n      return;\n    }\n\n    console.log(`Creating ${_commander2.default.args[0]} bot with a ${clientName} client.`);\n\n    // TODO: Pull out plugins that have dialogue and move them to the new bot.\n    _fs2.default.createReadStream(_path2.default.join(ssRoot, 'clients', `${clientName}.js`)).pipe(_fs2.default.createWriteStream(_path2.default.join(botPath, 'src', `server-${clientName}.js`)));\n\n    pkg.scripts.parse = 'parse -f';\n    pkg.scripts[`start-${clientName}`] = `npm run build && node lib/server-${clientName}.js`;\n\n    if (client === 'express') {\n      pkg.dependencies.express = '4.x';\n      pkg.dependencies['body-parser'] = '1.x';\n    } else if (client === 'hangout') {\n      pkg.dependencies['simple-xmpp'] = '1.x';\n    } else if (client === 'slack') {\n      pkg.dependencies['slack-client'] = '1.x';\n    } else if (client === 'telegram') {\n      pkg.dependencies['node-telegram-bot-api'] = '0.25.x';\n    } else if (client === 'twilio') {\n      pkg.dependencies.express = '4.x';\n      pkg.dependencies['express-session'] = '1.x';\n      pkg.dependencies['body-parser'] = '1.x';\n      pkg.dependencies['connect-mongo'] = '1.x';\n      pkg.dependencies.twilio = '2.x';\n    }\n  });\n\n  const firstRule = \"+ {^hasTag('hello')} *~2\\n- Hi!\\n- Hi, how are you?\\n- How are you?\\n- Hello\\n- Howdy\\n- Ola\";\n\n  write(_path2.default.join(botPath, 'package.json'), JSON.stringify(pkg, null, 2));\n  write(_path2.default.join(botPath, 'chat', 'main.ss'), firstRule);\n});","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bin/cleanup.js":"#!/usr/bin/env node\n'use strict';\n\nvar _commander = require('commander');\n\nvar _commander2 = _interopRequireDefault(_commander);\n\nvar _bot = require('../bot');\n\nvar _bot2 = _interopRequireDefault(_bot);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_commander2.default.version('1.0.1').option('--host [type]', 'Mongo Host', 'localhost').option('--port [type]', 'Mongo Port', '27017').option('--mongo [type]', 'Mongo Database Name', 'superscriptDB').option('--mongoURI [type]', 'Mongo URI').option('--importFile [type]', 'Parsed JSON file path', 'data.json').parse(process.argv);\n\nconst mongoURI = process.env.MONGO_URI || process.env.MONGODB_URI || _commander2.default.mongoURI || `mongodb://${_commander2.default.host}:${_commander2.default.port}/${_commander2.default.mongo}`;\n\n// The use case of this file is to refresh a currently running bot.\n// So the idea is to import a new file into a Mongo instance while preserving user data.\n// For now, just nuke everything and import all the data into the database.\n\n// TODO: Prevent clearing user data\n// const collectionsToRemove = ['users', 'topics', 'replies', 'gambits'];\n\nconst options = {\n  mongoURI,\n  importFile: _commander2.default.importFile\n};\n\n_bot2.default.setup(options, err => {\n  if (err) {\n    console.error(err);\n  }\n  console.log('Everything has been imported.');\n  process.exit();\n});","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/bin/parse.js":"#!/usr/bin/env node\n'use strict';\n\nvar _commander = require('commander');\n\nvar _commander2 = _interopRequireDefault(_commander);\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _ssParser = require('ss-parser');\n\nvar _ssParser2 = _interopRequireDefault(_ssParser);\n\nvar _sfacts = require('sfacts');\n\nvar _sfacts2 = _interopRequireDefault(_sfacts);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_commander2.default.version('1.0.2').option('-p, --path [type]', 'Input path', './chat').option('-o, --output [type]', 'Output options', 'data.json').option('-f, --force [type]', 'Force save if output file already exists', false).option('-F, --facts [type]', 'Fact system files path', files => files.split(','), []).option('--host [type]', 'Mongo Host', 'localhost').option('--port [type]', 'Mongo Port', '27017').option('--mongo [type]', 'Mongo Database Name', 'superscriptParse').option('--mongoURI [type]', 'Mongo URI').parse(process.argv);\n\nconst mongoURI = process.env.MONGO_URI || process.env.MONGODB_URI || _commander2.default.mongoURI || `mongodb://${_commander2.default.host}:${_commander2.default.port}/${_commander2.default.mongo}`;\n\n_fs2.default.exists(_commander2.default.output, exists => {\n  if (exists && !_commander2.default.force) {\n    console.log('File', _commander2.default.output, 'already exists, remove file first or use -f to force save.');\n    return process.exit();\n  }\n\n  return _sfacts2.default.load(mongoURI, _commander2.default.facts, true, (err, factSystem) => {\n    _ssParser2.default.parseDirectory(_commander2.default.path, { factSystem }, (err, result) => {\n      if (err) {\n        console.error(`Error parsing bot script: ${err}`);\n      }\n      _fs2.default.writeFile(_commander2.default.output, JSON.stringify(result, null, 4), err => {\n        if (err) throw err;\n        console.log(`Saved output to ${_commander2.default.output}`);\n        process.exit();\n      });\n    });\n  });\n});","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/plugins/alpha.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rhymes = require('rhymes');\n\nvar _rhymes2 = _interopRequireDefault(_rhymes);\n\nvar _syllablistic = require('syllablistic');\n\nvar _syllablistic2 = _interopRequireDefault(_syllablistic);\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _debug2.default)('AlphaPlugins');\n\nconst getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n// TODO: deprecate oppisite and replace with opposite\nconst oppisite = function oppisite(word, cb) {\n  debug('oppisite', word);\n\n  this.facts.db.get({ subject: word, predicate: 'opposite' }, (err, opp) => {\n    if (!_lodash2.default.isEmpty(opp)) {\n      let oppositeWord = opp[0].object;\n      oppositeWord = oppositeWord.replace(/_/g, ' ');\n      cb(null, oppositeWord);\n    } else {\n      cb(null, '');\n    }\n  });\n};\n\nconst rhymes = function rhymes(word, cb) {\n  debug('rhyming', word);\n\n  const rhymedWords = (0, _rhymes2.default)(word);\n  const i = getRandomInt(0, rhymedWords.length - 1);\n\n  if (rhymedWords.length !== 0) {\n    cb(null, rhymedWords[i].word.toLowerCase());\n  } else {\n    cb(null, null);\n  }\n};\n\nconst syllable = (word, cb) => cb(null, _syllablistic2.default.text(word));\n\nconst letterLookup = function letterLookup(cb) {\n  let reply = '';\n\n  const lastWord = this.message.lemWords.slice(-1)[0];\n  debug('--LastWord', lastWord);\n  debug('LemWords', this.message.lemWords);\n  const alpha = 'abcdefghijklmonpqrstuvwxyz'.split('');\n  const pos = alpha.indexOf(lastWord);\n  debug('POS', pos);\n  if (this.message.lemWords.indexOf('before') !== -1) {\n    if (alpha[pos - 1]) {\n      reply = alpha[pos - 1].toUpperCase();\n    } else {\n      reply = \"Don't be silly, there is nothing before A\";\n    }\n  } else if (this.message.lemWords.indexOf('after') !== -1) {\n    if (alpha[pos + 1]) {\n      reply = alpha[pos + 1].toUpperCase();\n    } else {\n      reply = 'haha, funny.';\n    }\n  } else {\n    const i = this.message.lemWords.indexOf('letter');\n    const loc = this.message.lemWords[i - 1];\n\n    if (loc === 'first') {\n      reply = 'It is A.';\n    } else if (loc === 'last') {\n      reply = 'It is Z.';\n    } else {\n      // Number or word number\n      // 1st, 2nd, 3rd, 4th or less then 99\n      if ((loc === 'st' || loc === 'nd' || loc === 'rd' || loc === 'th') && this.message.numbers.length !== 0) {\n        const num = parseInt(this.message.numbers[0]);\n        if (num > 0 && num <= 26) {\n          reply = `It is ${alpha[num - 1].toUpperCase()}`;\n        } else {\n          reply = 'seriously...';\n        }\n      }\n    }\n  }\n  cb(null, reply);\n};\n\nconst wordLength = function wordLength(cap, cb) {\n  if (typeof cap === 'string') {\n    const parts = cap.split(' ');\n    if (parts.length === 1) {\n      cb(null, cap.length);\n    } else if (parts[0].toLowerCase() === 'the' && parts.length === 3) {\n      // name bill, word bill\n      cb(null, parts.pop().length);\n    } else if (parts[0] === 'the' && parts[1].toLowerCase() === 'alphabet') {\n      cb(null, '26');\n    } else if (parts[0] === 'my' && parts.length === 2) {\n      // Varible lookup\n      const lookup = parts[1];\n      this.user.getVar(lookup, (e, v) => {\n        if (v !== null && v.length) {\n          cb(null, `There are ${v.length} letters in your ${lookup}.`);\n        } else {\n          cb(null, \"I don't know\");\n        }\n      });\n    } else if (parts[0] == 'this' && parts.length == 2) {\n      // this phrase, this sentence\n      cb(null, `That phrase has ${this.message.raw.length} characters. I think.`);\n    } else {\n      cb(null, 'I think there is about 10 characters. :)');\n    }\n  } else {\n    cap(null, '');\n  }\n};\n\nconst nextNumber = function nextNumber(cb) {\n  let reply = '';\n  const num = this.message.numbers.slice(-1)[0];\n\n  if (num) {\n    if (this.message.lemWords.indexOf('before') !== -1) {\n      reply = parseInt(num) - 1;\n    }\n    if (this.message.lemWords.indexOf('after') !== -1) {\n      reply = parseInt(num) + 1;\n    }\n  }\n\n  cb(null, reply);\n};\n\nexports.default = {\n  letterLookup,\n  nextNumber,\n  oppisite,\n  rhymes,\n  syllable,\n  wordLength\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/plugins/compare.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _async = require('async');\n\nvar _async2 = _interopRequireDefault(_async);\n\nvar _utils = require('../bot/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _debug2.default)('Compare Plugin');\n\nconst createFact = function createFact(s, v, o, cb) {\n  this.user.memory.create(s, v, o, false, () => {\n    this.facts.db.get({ subject: v, predicate: 'opposite' }, (e, r) => {\n      if (r.length !== 0) {\n        this.user.memory.create(o, r[0].object, s, false, () => {\n          cb(null, '');\n        });\n      } else {\n        cb(null, '');\n      }\n    });\n  });\n};\n\nexports.default = {\n  createFact\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/plugins/math.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n  Math functions for\n  - evaluating expressions\n  - converting functions\n  - sequence functions\n*/\n\nconst roman = require('roman-numerals');\nconst debug = require('debug')('mathPlugin');\n\n// const evaluateExpression = function evaluateExpression(cb) {\n//   if (this.message.numericExp || (this.message.halfNumericExp && this.user.prevAns)) {\n//     const answer = math.parse(this.message.cwords, this.user.prevAns);\n//     let suggestedReply;\n//     if (answer) {\n//       this.user.prevAns = answer;\n//       console.log('Prev', this.user);\n//       suggestedReply = `I think it is ${answer}`;\n//     } else {\n//       suggestedReply = 'What do I look like, a computer?';\n//     }\n//     cb(null, suggestedReply);\n//   } else {\n//     cb(true, '');\n//   }\n// };\n\nconst numToRoman = function numToRoman(cb) {\n  const suggest = `I think it is ${roman.toRoman(this.message.numbers[0])}`;\n  cb(null, suggest);\n};\n\nconst numToHex = function numToHex(cb) {\n  const suggest = `I think it is ${parseInt(this.message.numbers[0], 10).toString(16)}`;\n  cb(null, suggest);\n};\n\nconst numToBinary = function numToBinary(cb) {\n  const suggest = `I think it is ${parseInt(this.message.numbers[0], 10).toString(2)}`;\n  cb(null, suggest);\n};\n\nconst numMissing = function numMissing(cb) {\n  // What number are missing 1, 3, 5, 7\n  if (this.message.lemWords.indexOf('missing') !== -1 && this.message.numbers.length !== 0) {\n    const numArray = this.message.numbers.sort();\n    const mia = [];\n    for (let i = 1; i < numArray.length; i++) {\n      if (numArray[i] - numArray[i - 1] !== 1) {\n        const x = numArray[i] - numArray[i - 1];\n        let j = 1;\n        while (j < x) {\n          mia.push(parseFloat(numArray[i - 1]) + j);\n          j += 1;\n        }\n      }\n    }\n    const s = mia.sort((a, b) => a - b);\n    cb(null, `I think it is ${s.join(' ')}`);\n  } else {\n    cb(true, '');\n  }\n};\n\n// Sequence\n// const numSequence = function numSequence(cb) {\n//   if (this.message.lemWords.indexOf('sequence') !== -1 && this.message.numbers.length !== 0) {\n//     debug('Finding the next number in the series');\n//     let numArray = this.message.numbers.map(item => parseInt(item));\n//     numArray = numArray.sort((a, b) => (a - b));\n\n//     let suggest;\n//     if (math.arithGeo(numArray) === 'Arithmetic') {\n//       let x;\n//       for (let i = 1; i < numArray.length; i++) {\n//         x = numArray[i] - numArray[i - 1];\n//       }\n//       suggest = `I think it is ${parseInt(numArray.pop()) + x}`;\n//     } else if (math.arithGeo(numArray) === 'Geometric') {\n//       const a = numArray[1];\n//       const r = a / numArray[0];\n//       suggest = `I think it is ${numArray.pop() * r}`;\n//     }\n\n//     cb(null, suggest);\n//   } else {\n//     cb(true, '');\n//   }\n// };\n\nexports.default = {\n  // evaluateExpression,\n  numMissing,\n  // numSequence,\n  numToBinary,\n  numToHex,\n  numToRoman\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/plugins/message.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst addMessageProp = function addMessageProp(key, value, callback) {\n  if (key !== '' && value !== '') {\n    return callback(null, { [key]: value });\n  }\n\n  return callback(null, '');\n};\n\nconst hasTag = function hasTag(tag, callback) {\n  if (this.message.tags.indexOf(tag) !== -1) {\n    return callback(null, true);\n  }\n  return callback(null, false);\n};\n\nexports.default = { addMessageProp, hasTag };","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/plugins/time.js":"'use strict';\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst COEFF = 1000 * 60 * 5;\n\nconst getSeason = function getSeason() {\n  const now = (0, _moment2.default)();\n  now.dayOfYear();\n  const doy = now.dayOfYear();\n\n  if (doy > 80 && doy < 172) {\n    return 'spring';\n  } else if (doy > 172 && doy < 266) {\n    return 'summer';\n  } else if (doy > 266 && doy < 357) {\n    return 'fall';\n  } else if (doy < 80 || doy > 357) {\n    return 'winter';\n  }\n  return 'unknown';\n};\n\nexports.getDOW = function getDOW(cb) {\n  cb(null, (0, _moment2.default)().format('dddd'));\n};\n\nexports.getDate = function getDate(cb) {\n  cb(null, (0, _moment2.default)().format('ddd, MMMM Do'));\n};\n\nexports.getDateTomorrow = function getDateTomorrow(cb) {\n  const date = (0, _moment2.default)().add('d', 1).format('ddd, MMMM Do');\n  cb(null, date);\n};\n\nexports.getSeason = function getSeason(cb) {\n  cb(null, getSeason());\n};\n\nexports.getTime = function getTime(cb) {\n  const date = new Date();\n  const rounded = new Date(Math.round(date.getTime() / COEFF) * COEFF);\n  const time = (0, _moment2.default)(rounded).format('h:mm');\n  cb(null, `The time is ${time}`);\n};\n\nexports.getGreetingTimeOfDay = function getGreetingTimeOfDay(cb) {\n  const date = new Date();\n  const rounded = new Date(Math.round(date.getTime() / COEFF) * COEFF);\n  const time = (0, _moment2.default)(rounded).format('H');\n  let tod;\n  if (time < 12) {\n    tod = 'morning';\n  } else if (time < 17) {\n    tod = 'afternoon';\n  } else {\n    tod = 'evening';\n  }\n\n  cb(null, tod);\n};\n\nexports.getTimeOfDay = function getTimeOfDay(cb) {\n  const date = new Date();\n  const rounded = new Date(Math.round(date.getTime() / COEFF) * COEFF);\n  const time = (0, _moment2.default)(rounded).format('H');\n  let tod;\n  if (time < 12) {\n    tod = 'morning';\n  } else if (time < 17) {\n    tod = 'afternoon';\n  } else {\n    tod = 'night';\n  }\n\n  cb(null, tod);\n};\n\nexports.getDayOfWeek = function getDayOfWeek(cb) {\n  cb(null, (0, _moment2.default)().format('dddd'));\n};\n\nexports.getMonth = function getMonth(cb) {\n  let reply = '';\n  if (this.message.words.indexOf('next') !== -1) {\n    reply = (0, _moment2.default)().add('M', 1).format('MMMM');\n  } else if (this.message.words.indexOf('previous') !== -1) {\n    reply = (0, _moment2.default)().subtract('M', 1).format('MMMM');\n  } else if (this.message.words.indexOf('first') !== -1) {\n    reply = 'January';\n  } else if (this.message.words.indexOf('last') !== -1) {\n    reply = 'December';\n  } else {\n    reply = (0, _moment2.default)().format('MMMM');\n  }\n  cb(null, reply);\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/plugins/user.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _debug2.default)('SS:UserFacts');\n\nconst save = function save(key, value, cb) {\n  const memory = this.user.memory;\n  const userId = this.user.id;\n\n  if (arguments.length !== 3) {\n    console.log('WARNING\\nValue not found in save function.');\n    if (_lodash2.default.isFunction(value)) {\n      cb = value;\n      value = '';\n    }\n  }\n\n  memory.db.get({ subject: key, predicate: userId }, (err, results) => {\n    if (!_lodash2.default.isEmpty(results)) {\n      memory.db.del(results[0], () => {\n        memory.db.put({ subject: key, predicate: userId, object: value }, () => {\n          cb(null, '');\n        });\n      });\n    } else {\n      memory.db.put({ subject: key, predicate: userId, object: value }, err => {\n        cb(null, '');\n      });\n    }\n  });\n};\n\nconst hasItem = function hasItem(key, bool, cb) {\n  const memory = this.user.memory;\n  const userId = this.user.id;\n\n  debug('getVar', key, bool, userId);\n  memory.db.get({ subject: key, predicate: userId }, (err, res) => {\n    if (!_lodash2.default.isEmpty(res)) {\n      cb(null, bool === 'true');\n    } else {\n      cb(null, bool === 'false');\n    }\n  });\n};\n\nconst get = function get(key, cb) {\n  const memory = this.user.memory;\n  const userId = this.user.id;\n\n  debug('getVar', key, userId);\n\n  memory.db.get({ subject: key, predicate: userId }, (err, res) => {\n    if (res && res.length !== 0) {\n      cb(err, res[0].object);\n    } else {\n      cb(err, '');\n    }\n  });\n};\n\n// Query SV return O and if that failes query OV return S\nconst queryUserFact = function queryUserFact(subject, verb, cb) {\n  var subject = subject.replace(/\\s/g, \"_\").toLowerCase();\n  var memory = this.user.memory;\n  memory.db.get({ subject: subject, predicate: verb }, function (err, result) {\n    if (!_lodash2.default.isEmpty(result)) {\n      cb(null, result[0].object);\n    } else {\n      memory.db.get({ object: subject, predicate: verb }, function (err, result) {\n        if (!_lodash2.default.isEmpty(result)) {\n          cb(null, result[0].subject);\n        } else {\n          cb(null, \"\");\n        }\n      });\n    }\n  });\n};\n\nconst createUserFact = function createUserFact(subject, predicate, object, cb) {\n  const memory = this.user.memory;\n\n  var subject = subject.replace(/\\s/g, \"_\").toLowerCase();\n  var object = object.replace(/\\s/g, \"_\").toLowerCase();\n\n  memory.db.get({ subject, predicate, object }, (err, results) => {\n    if (!_lodash2.default.isEmpty(results)) {\n      memory.db.del(results[0], () => {\n        memory.db.put({ subject, predicate, object }, () => {\n          cb(null, '');\n        });\n      });\n    } else {\n      memory.db.put({ subject, predicate, object }, err => {\n        cb(null, '');\n      });\n    }\n  });\n};\n\nconst known = function known(bool, cb) {\n  const memory = this.user.memory;\n  const name = this.message.names && !_lodash2.default.isEmpty(this.message.names) ? this.message.names[0] : '';\n  memory.db.get({ subject: name.toLowerCase() }, (err, res1) => {\n    memory.db.get({ object: name.toLowerCase() }, (err, res2) => {\n      if (_lodash2.default.isEmpty(res1) && _lodash2.default.isEmpty(res2)) {\n        cb(null, bool === 'false');\n      } else {\n        cb(null, bool === 'true');\n      }\n    });\n  });\n};\n\nconst inTopic = function inTopic(topic, cb) {\n  if (topic === this.user.currentTopic) {\n    cb(null, 'true');\n  } else {\n    cb(null, 'false');\n  }\n};\n\nexports.default = {\n  createUserFact,\n  queryUserFact,\n  get,\n  hasItem,\n  inTopic,\n  known,\n  save\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/plugins/wordnet.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _wordnet = require('../bot/reply/wordnet');\n\nvar _wordnet2 = _interopRequireDefault(_wordnet);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst wordnetDefine = function wordnetDefine(cb) {\n  const args = Array.prototype.slice.call(arguments);\n  let word;\n\n  if (args.length === 2) {\n    word = args[0];\n  } else {\n    word = this.message.words.pop();\n  }\n\n  _wordnet2.default.define(word).then(result => {\n    cb(null, `The Definition of ${word} is ${result}`);\n  }).catch(() => {\n    cb(null, `There is no definition for the word ${word}!`);\n  });\n};\n\nexports.default = { wordnetDefine };","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/plugins/words.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _pluralize = require('pluralize');\n\nvar _pluralize2 = _interopRequireDefault(_pluralize);\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _utils = require('../bot/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _debug2.default)('Word Plugin');\n\nconst plural = function plural(word, cb) {\n  // Sometimes WordNet will give us more then one word\n  let reply;\n  const parts = word.split(' ');\n\n  if (parts.length === 2) {\n    reply = `${_pluralize2.default.plural(parts[0])} ${parts[1]}`;\n  } else {\n    reply = _pluralize2.default.plural(word);\n  }\n\n  cb(null, reply);\n};\n\nconst not = function not(word, cb) {\n  const words = word.split('|');\n  const results = _utils2.default.inArray(this.message.words, words);\n  debug('RES', results);\n  cb(null, results === false);\n};\n\nconst lowercase = function lowercase(word, cb) {\n  if (word) {\n    cb(null, word.toLowerCase());\n  } else {\n    cb(null, '');\n  }\n};\n\nexports.default = {\n  lowercase,\n  not,\n  plural\n};","/home/travis/build/npmtest/node-npmtest-superscript/node_modules/superscript/lib/plugins/test.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// This is used in a test to verify fall though works\n// TODO: Move this into a fixture.\nconst bail = function bail(cb) {\n  cb(true, null);\n};\n\nconst one = function one(cb) {\n  cb(null, 'one');\n};\n\nconst num = function num(n, cb) {\n  cb(null, n);\n};\n\nconst changetopic = function changetopic(n, cb) {\n  this.user.setTopic(n).then(() => cb(null, ''));\n};\n\nconst changefunctionreply = function changefunctionreply(newtopic, cb) {\n  cb(null, `{topic=${newtopic}}`);\n};\n\nconst doSomething = function doSomething(cb) {\n  console.log('this.message.raw', this.message.raw);\n  cb(null, 'function');\n};\n\nconst breakFunc = function breakFunc(cb) {\n  cb(null, '', true);\n};\n\nconst nobreak = function nobreak(cb) {\n  cb(null, '', false);\n};\n\nconst objparam1 = function objparam1(cb) {\n  const data = {\n    text: 'world',\n    attachments: [{\n      text: 'Optional text that appears *within* the attachment'\n    }]\n  };\n  cb(null, data);\n};\n\nconst objparam2 = function objparam2(cb) {\n  cb(null, { test: 'hello', text: 'world' });\n};\n\nconst showScope = function showScope(cb) {\n  cb(null, `${this.extraScope.key} ${this.user.id} ${this.message.clean}`);\n};\n\nconst word = function word(word1, word2, cb) {\n  cb(null, word1 === word2);\n};\n\nconst hasFirstName = function hasFirstName(bool, cb) {\n  this.user.getVar('firstName', (e, name) => {\n    if (name !== null) {\n      cb(null, bool === 'true');\n    } else {\n      cb(null, bool === 'false');\n    }\n  });\n};\n\nconst getUserId = function getUserId(cb) {\n  const userID = this.user.id;\n  const that = this;\n  // console.log(\"CMP1\", _.isEqual(userID, that.user.id));\n  return that.bot.getUser('userB', (err, user) => {\n    console.log('CMP2', _lodash2.default.isEqual(userID, that.user.id));\n    cb(null, that.user.id);\n  });\n};\n\nconst hasName = function hasName(bool, cb) {\n  this.user.getVar('name', (e, name) => {\n    if (name !== null) {\n      cb(null, bool === 'true');\n    } else {\n      // We have no name\n      cb(null, bool === 'false');\n    }\n  });\n};\n\nconst testCustomArgs = function testCustomArgs(myObj, myArr, cb) {\n  const part1 = myObj.myKey;\n  const part2 = myArr[0];\n  cb(null, `${part1} ${part2}`);\n};\n\nconst testMoreTags = function testMoreTags(topic, trigger, cb) {\n  cb(null, `^topicRedirect(\"${topic}\", \"${trigger}\")`);\n};\n\n// This function is called from the topic filter function\n// Return true if you want the method to filter it out\nconst filterTopic = function filterTopic(cb) {\n  if (this.topic.name === 'filter2') {\n    cb(null, false);\n  } else {\n    cb(null, true);\n  }\n};\n\nexports.default = {\n  bail,\n  breakFunc,\n  doSomething,\n  changefunctionreply,\n  changetopic,\n  getUserId,\n  hasFirstName,\n  hasName,\n  nobreak,\n  num,\n  objparam1,\n  objparam2,\n  one,\n  showScope,\n  testCustomArgs,\n  testMoreTags,\n  word,\n  filterTopic\n};"}